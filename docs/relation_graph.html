<html>
    <head>
        <meta charset="utf-8">
        
            <script src="lib/bindings/utils.js"></script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 800px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             

             

             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#97c2fc", "id": "A", "label": "A", "shape": "dot", "title": "A"}, {"color": "#97c2fc", "id": "B0", "label": "B0", "shape": "dot", "title": "B0"}, {"color": "#97c2fc", "id": "I_p", "label": "I_p", "shape": "dot", "title": "I_p"}, {"color": "#97c2fc", "id": "P_loss", "label": "P_loss", "shape": "dot", "title": "P_loss"}, {"color": "#97c2fc", "id": "R", "label": "R", "shape": "dot", "title": "R"}, {"color": "#97c2fc", "id": "R_max", "label": "R_max", "shape": "dot", "title": "R_max"}, {"color": "#97c2fc", "id": "R_min", "label": "R_min", "shape": "dot", "title": "R_min"}, {"color": "#97c2fc", "id": "S_p", "label": "S_p", "shape": "dot", "title": "S_p"}, {"color": "#97c2fc", "id": "V_p", "label": "V_p", "shape": "dot", "title": "V_p"}, {"color": "#97c2fc", "id": "W_th", "label": "W_th", "shape": "dot", "title": "W_th"}, {"color": "#97c2fc", "id": "Z_max", "label": "Z_max", "shape": "dot", "title": "Z_max"}, {"color": "#97c2fc", "id": "Z_min", "label": "Z_min", "shape": "dot", "title": "Z_min"}, {"color": "#97c2fc", "id": "a", "label": "a", "shape": "dot", "title": "a"}, {"color": "#97c2fc", "id": "afuel", "label": "afuel", "shape": "dot", "title": "afuel"}, {"color": "#97c2fc", "id": "beta_limit", "label": "beta_limit", "shape": "dot", "title": "beta_limit"}, {"color": "#97c2fc", "id": "delta", "label": "delta", "shape": "dot", "title": "delta"}, {"color": "#97c2fc", "id": "delta_95", "label": "delta_95", "shape": "dot", "title": "delta_95"}, {"color": "#97c2fc", "id": "dnla20", "label": "dnla20", "shape": "dot", "title": "dnla20"}, {"color": "#97c2fc", "id": "f_D", "label": "f_D", "shape": "dot", "title": "f_D"}, {"color": "#97c2fc", "id": "f_GW", "label": "f_GW", "shape": "dot", "title": "f_GW"}, {"color": "#97c2fc", "id": "f_He3", "label": "f_He3", "shape": "dot", "title": "f_He3"}, {"color": "#97c2fc", "id": "f_He4", "label": "f_He4", "shape": "dot", "title": "f_He4"}, {"color": "#97c2fc", "id": "f_T", "label": "f_T", "shape": "dot", "title": "f_T"}, {"color": "#97c2fc", "id": "kappa", "label": "kappa", "shape": "dot", "title": "kappa"}, {"color": "#97c2fc", "id": "kappa_95", "label": "kappa_95", "shape": "dot", "title": "kappa_95"}, {"color": "#97c2fc", "id": "kappa_ipb", "label": "kappa_ipb", "shape": "dot", "title": "kappa_ipb"}, {"color": "#97c2fc", "id": "n_D", "label": "n_D", "shape": "dot", "title": "n_D"}, {"color": "#97c2fc", "id": "n_GW", "label": "n_GW", "shape": "dot", "title": "n_GW"}, {"color": "#97c2fc", "id": "n_He3", "label": "n_He3", "shape": "dot", "title": "n_He3"}, {"color": "#97c2fc", "id": "n_He4", "label": "n_He4", "shape": "dot", "title": "n_He4"}, {"color": "#97c2fc", "id": "n_SUDO", "label": "n_SUDO", "shape": "dot", "title": "n_SUDO"}, {"color": "#97c2fc", "id": "n_T", "label": "n_T", "shape": "dot", "title": "n_T"}, {"color": "#97c2fc", "id": "n_avg", "label": "n_avg", "shape": "dot", "title": "n_avg"}, {"color": "#97c2fc", "id": "n_e", "label": "n_e", "shape": "dot", "title": "n_e"}, {"color": "#97c2fc", "id": "n_i", "label": "n_i", "shape": "dot", "title": "n_i"}, {"color": "#97c2fc", "id": "n_la", "label": "n_la", "shape": "dot", "title": "n_la"}, {"color": "#97c2fc", "id": "p_th", "label": "p_th", "shape": "dot", "title": "p_th"}, {"color": "#97c2fc", "id": "squareness", "label": "squareness", "shape": "dot", "title": "squareness"}, {"color": "#97c2fc", "id": "tau_E", "label": "tau_E", "shape": "dot", "title": "tau_E"}]);
                  edges = new vis.DataSet([{"arrows": "to", "color": "#9edae5", "from": "I_p", "label": "tau_E_hubbard_nominal", "relation": "tau_E_hubbard_nominal", "title": "tau_E_hubbard_nominal", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "B0", "label": "tau_E_hubbard_nominal", "relation": "tau_E_hubbard_nominal", "title": "tau_E_hubbard_nominal", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "dnla20", "label": "tau_E_hubbard_nominal", "relation": "tau_E_hubbard_nominal", "title": "tau_E_hubbard_nominal", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "P_loss", "label": "tau_E_hubbard_nominal", "relation": "tau_E_hubbard_nominal", "title": "tau_E_hubbard_nominal", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "I_p", "label": "tau_E_iter_ipb98y2", "relation": "tau_E_iter_ipb98y2", "title": "tau_E_iter_ipb98y2", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "B0", "label": "tau_E_iter_ipb98y2", "relation": "tau_E_iter_ipb98y2", "title": "tau_E_iter_ipb98y2", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "n_la", "label": "tau_E_iter_ipb98y2", "relation": "tau_E_iter_ipb98y2", "title": "tau_E_iter_ipb98y2", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "P_loss", "label": "tau_E_iter_ipb98y2", "relation": "tau_E_iter_ipb98y2", "title": "tau_E_iter_ipb98y2", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "R", "label": "tau_E_iter_ipb98y2", "relation": "tau_E_iter_ipb98y2", "title": "tau_E_iter_ipb98y2", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "kappa_ipb", "label": "tau_E_iter_ipb98y2", "relation": "tau_E_iter_ipb98y2", "title": "tau_E_iter_ipb98y2", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "A", "label": "tau_E_iter_ipb98y2", "relation": "tau_E_iter_ipb98y2", "title": "tau_E_iter_ipb98y2", "to": "tau_E"}, {"arrows": "to", "color": "#9edae5", "from": "afuel", "label": "tau_E_iter_ipb98y2", "relation": "tau_E_iter_ipb98y2", "title": "tau_E_iter_ipb98y2", "to": "tau_E"}, {"arrows": "to", "color": "#7f7f7f", "from": "p_th", "label": "Thermal stored energy", "relation": "Thermal stored energy", "title": "Thermal stored energy", "to": "W_th"}, {"arrows": "to", "color": "#7f7f7f", "from": "V_p", "label": "Thermal stored energy", "relation": "Thermal stored energy", "title": "Thermal stored energy", "to": "W_th"}, {"arrows": "to", "color": "#98df8a", "from": "W_th", "label": "Energy confinement time", "relation": "Energy confinement time", "title": "Energy confinement time", "to": "tau_E"}, {"arrows": "to", "color": "#98df8a", "from": "P_loss", "label": "Energy confinement time", "relation": "Energy confinement time", "title": "Energy confinement time", "to": "tau_E"}, {"arrows": "to", "color": "#8c564b", "from": "R_max", "label": "Major radius", "relation": "Major radius", "title": "Major radius", "to": "R"}, {"arrows": "to", "color": "#8c564b", "from": "R_min", "label": "Major radius", "relation": "Major radius", "title": "Major radius", "to": "R"}, {"arrows": "to", "color": "#1f77b4", "from": "R", "label": "Aspect ratio", "relation": "Aspect ratio", "title": "Aspect ratio", "to": "A"}, {"arrows": "to", "color": "#1f77b4", "from": "a", "label": "Aspect ratio", "relation": "Aspect ratio", "title": "Aspect ratio", "to": "A"}, {"arrows": "to", "color": "#2ca02c", "from": "Z_max", "label": "Elongation", "relation": "Elongation", "title": "Elongation", "to": "kappa"}, {"arrows": "to", "color": "#2ca02c", "from": "Z_min", "label": "Elongation", "relation": "Elongation", "title": "Elongation", "to": "kappa"}, {"arrows": "to", "color": "#2ca02c", "from": "R_max", "label": "Elongation", "relation": "Elongation", "title": "Elongation", "to": "kappa"}, {"arrows": "to", "color": "#2ca02c", "from": "R_min", "label": "Elongation", "relation": "Elongation", "title": "Elongation", "to": "kappa"}, {"arrows": "to", "color": "#98df8a", "from": "kappa_95", "label": "Elongation 95%", "relation": "Elongation 95%", "title": "Elongation 95%", "to": "kappa"}, {"arrows": "to", "color": "#bcbd22", "from": "delta_95", "label": "Triangularity 95%", "relation": "Triangularity 95%", "title": "Triangularity 95%", "to": "delta"}, {"arrows": "to", "color": "#8c564b", "from": "V_p", "label": "IPB elongation from volume", "relation": "IPB elongation from volume", "title": "IPB elongation from volume", "to": "kappa_ipb"}, {"arrows": "to", "color": "#8c564b", "from": "R", "label": "IPB elongation from volume", "relation": "IPB elongation from volume", "title": "IPB elongation from volume", "to": "kappa_ipb"}, {"arrows": "to", "color": "#8c564b", "from": "a", "label": "IPB elongation from volume", "relation": "IPB elongation from volume", "title": "IPB elongation from volume", "to": "kappa_ipb"}, {"arrows": "to", "color": "#c7c7c7", "from": "a", "label": "Tokamak volume", "relation": "Tokamak volume", "title": "Tokamak volume", "to": "V_p"}, {"arrows": "to", "color": "#c7c7c7", "from": "R", "label": "Tokamak volume", "relation": "Tokamak volume", "title": "Tokamak volume", "to": "V_p"}, {"arrows": "to", "color": "#c7c7c7", "from": "kappa", "label": "Tokamak volume", "relation": "Tokamak volume", "title": "Tokamak volume", "to": "V_p"}, {"arrows": "to", "color": "#c7c7c7", "from": "delta", "label": "Tokamak volume", "relation": "Tokamak volume", "title": "Tokamak volume", "to": "V_p"}, {"arrows": "to", "color": "#c7c7c7", "from": "squareness", "label": "Tokamak volume", "relation": "Tokamak volume", "title": "Tokamak volume", "to": "V_p"}, {"arrows": "to", "color": "#c7c7c7", "from": "a", "label": "Tokamak surface", "relation": "Tokamak surface", "title": "Tokamak surface", "to": "S_p"}, {"arrows": "to", "color": "#c7c7c7", "from": "R", "label": "Tokamak surface", "relation": "Tokamak surface", "title": "Tokamak surface", "to": "S_p"}, {"arrows": "to", "color": "#c7c7c7", "from": "kappa", "label": "Tokamak surface", "relation": "Tokamak surface", "title": "Tokamak surface", "to": "S_p"}, {"arrows": "to", "color": "#c7c7c7", "from": "delta", "label": "Tokamak surface", "relation": "Tokamak surface", "title": "Tokamak surface", "to": "S_p"}, {"arrows": "to", "color": "#c7c7c7", "from": "squareness", "label": "Tokamak surface", "relation": "Tokamak surface", "title": "Tokamak surface", "to": "S_p"}, {"arrows": "to", "color": "#c49c94", "from": "A", "label": "ST elongation vs aspect ratio", "relation": "ST elongation vs aspect ratio", "title": "ST elongation vs aspect ratio", "to": "kappa"}, {"arrows": "to", "color": "#e377c2", "from": "A", "label": "ST triangularity vs aspect ratio", "relation": "ST triangularity vs aspect ratio", "title": "ST triangularity vs aspect ratio", "to": "delta"}, {"arrows": "to", "color": "#17becf", "from": "a", "label": "Troyon beta limit", "relation": "Troyon beta limit", "title": "Troyon beta limit", "to": "beta_limit"}, {"arrows": "to", "color": "#17becf", "from": "B0", "label": "Troyon beta limit", "relation": "Troyon beta limit", "title": "Troyon beta limit", "to": "beta_limit"}, {"arrows": "to", "color": "#17becf", "from": "I_p", "label": "Troyon beta limit", "relation": "Troyon beta limit", "title": "Troyon beta limit", "to": "beta_limit"}, {"arrows": "to", "color": "#ff9896", "from": "I_p", "label": "Greenwald density limit", "relation": "Greenwald density limit", "title": "Greenwald density limit", "to": "n_GW"}, {"arrows": "to", "color": "#ff9896", "from": "a", "label": "Greenwald density limit", "relation": "Greenwald density limit", "title": "Greenwald density limit", "to": "n_GW"}, {"arrows": "to", "color": "#d62728", "from": "n_GW", "label": "Greenwald density fraction", "relation": "Greenwald density fraction", "title": "Greenwald density fraction", "to": "f_GW"}, {"arrows": "to", "color": "#d62728", "from": "n_avg", "label": "Greenwald density fraction", "relation": "Greenwald density fraction", "title": "Greenwald density fraction", "to": "f_GW"}, {"arrows": "to", "color": "#f7b6d2", "from": "P_loss", "label": "Sudo density limit", "relation": "Sudo density limit", "title": "Sudo density limit", "to": "n_SUDO"}, {"arrows": "to", "color": "#f7b6d2", "from": "B0", "label": "Sudo density limit", "relation": "Sudo density limit", "title": "Sudo density limit", "to": "n_SUDO"}, {"arrows": "to", "color": "#f7b6d2", "from": "R", "label": "Sudo density limit", "relation": "Sudo density limit", "title": "Sudo density limit", "to": "n_SUDO"}, {"arrows": "to", "color": "#f7b6d2", "from": "a", "label": "Sudo density limit", "relation": "Sudo density limit", "title": "Sudo density limit", "to": "n_SUDO"}, {"arrows": "to", "color": "#ffbb78", "from": "n_avg", "label": "Electron density from volume-averaged...", "relation": "Electron density from volume-averaged density", "title": "Electron density from volume-averaged density", "to": "n_e"}, {"arrows": "to", "color": "#ff7f0e", "from": "n_i", "label": "Electron density from ion fractions", "relation": "Electron density from ion fractions", "title": "Electron density from ion fractions", "to": "n_e"}, {"arrows": "to", "color": "#ff7f0e", "from": "f_D", "label": "Electron density from ion fractions", "relation": "Electron density from ion fractions", "title": "Electron density from ion fractions", "to": "n_e"}, {"arrows": "to", "color": "#ff7f0e", "from": "f_T", "label": "Electron density from ion fractions", "relation": "Electron density from ion fractions", "title": "Electron density from ion fractions", "to": "n_e"}, {"arrows": "to", "color": "#ff7f0e", "from": "f_He3", "label": "Electron density from ion fractions", "relation": "Electron density from ion fractions", "title": "Electron density from ion fractions", "to": "n_e"}, {"arrows": "to", "color": "#ff7f0e", "from": "f_He4", "label": "Electron density from ion fractions", "relation": "Electron density from ion fractions", "title": "Electron density from ion fractions", "to": "n_e"}, {"arrows": "to", "color": "#1f77b4", "from": "f_D", "label": "Deuterium density from fraction", "relation": "Deuterium density from fraction", "title": "Deuterium density from fraction", "to": "n_D"}, {"arrows": "to", "color": "#1f77b4", "from": "n_i", "label": "Deuterium density from fraction", "relation": "Deuterium density from fraction", "title": "Deuterium density from fraction", "to": "n_D"}, {"arrows": "to", "color": "#dbdb8d", "from": "f_T", "label": "Tritium density from fraction", "relation": "Tritium density from fraction", "title": "Tritium density from fraction", "to": "n_T"}, {"arrows": "to", "color": "#dbdb8d", "from": "n_i", "label": "Tritium density from fraction", "relation": "Tritium density from fraction", "title": "Tritium density from fraction", "to": "n_T"}, {"arrows": "to", "color": "#9467bd", "from": "f_He3", "label": "Helium-3 density from fraction", "relation": "Helium-3 density from fraction", "title": "Helium-3 density from fraction", "to": "n_He3"}, {"arrows": "to", "color": "#9467bd", "from": "n_i", "label": "Helium-3 density from fraction", "relation": "Helium-3 density from fraction", "title": "Helium-3 density from fraction", "to": "n_He3"}, {"arrows": "to", "color": "#c5b0d5", "from": "f_He4", "label": "Helium-4 density from fraction", "relation": "Helium-4 density from fraction", "title": "Helium-4 density from fraction", "to": "n_He4"}, {"arrows": "to", "color": "#c5b0d5", "from": "n_i", "label": "Helium-4 density from fraction", "relation": "Helium-4 density from fraction", "title": "Helium-4 density from fraction", "to": "n_He4"}, {"arrows": "to", "color": "#aec7e8", "from": "n_D", "label": "Deuterium fraction from density", "relation": "Deuterium fraction from density", "title": "Deuterium fraction from density", "to": "f_D"}, {"arrows": "to", "color": "#aec7e8", "from": "n_i", "label": "Deuterium fraction from density", "relation": "Deuterium fraction from density", "title": "Deuterium fraction from density", "to": "f_D"}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {"nodes": {"shape": "dot", "size": 18, "font": {"size": 20, "face": "monospace"}}, "edges": {"arrows": {"to": {"enabled": true}}, "font": {"size": 16, "align": "middle"}}, "interaction": {"hover": true}, "physics": {"barnesHut": {"springLength": 140, "springConstant": 0.03}}};

                  


                  

                  network = new vis.Network(container, data, options);

                  

                  

                  


                  

                  return network;

              }
              (function(){
  try {
    var __net = drawGraph();
    window.__relationGraph__ = {
      network: __net,
      nodes: (typeof nodes !== 'undefined' ? nodes : null),
      edges: (typeof edges !== 'undefined' ? edges : null)
    };
    window.network = __net;
  } catch (e) {
    console.error('relation_graph: drawGraph() failed', e);
  }
})();
        </script>
    
<style>
  #relation-toolbox {
    position: fixed;
    top: 12px;
    right: 12px;
    z-index: 9999;
    background: #fff;
    border: 1px solid #ccc;
    padding: 10px;
    max-width: 420px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
    font-family: monospace;
  }
  #relation-toolbox label,
  #relation-toolbox input,
  #relation-toolbox button,
  #relation-toolbox pre {
    font-size: 14px;
  }
  #relation-toolbox input {
    width: 260px;
    padding: 6px;
  }
  #relation-toolbox button {
    margin-left: 6px;
    padding: 6px 10px;
  }
  #search-suggestions {
    margin-top: 6px;
    border: 1px solid #ddd;
    background: #fafafa;
    max-height: 140px;
    overflow: auto;
    display: none;
  }
  #search-suggestions .suggestion {
    padding: 4px 6px;
    cursor: pointer;
  }
  #search-suggestions .suggestion:hover {
    background: #eef;
  }
  #relation-toolbox pre {
    margin: 8px 0 0 0;
    padding: 8px;
    border: 1px solid #ddd;
    max-height: 320px;
    overflow: auto;
    white-space: pre-wrap;
  }
</style>
<div id="relation-toolbox">
  <label for="search-input"><strong>Search</strong></label><br />
  <input id="search-input" type="text" placeholder="Variable, relation, alias, or #tag" />
  <button id="search-button">Go</button>
  <div id="search-suggestions"></div>
  <div style="margin-top:8px;"><strong>Info</strong></div>
  <pre id="info-panel">Click a node or edge to view details.</pre>
</div>
<script type="text/javascript">
window.variableInfo = {};
window.variableAliases = {};
window.relationInfo = {"Thermal stored energy": [{"function": "thermal_stored_energy", "module": "fusdb.relations.confinement.plasma_stored_energy", "source": "@Reactor.relation(\"plasma\", name=\"Thermal stored energy\", output=\"W_th\", variables=(\"p_th\", \"V_p\"))\ndef thermal_stored_energy(p_th: float, V_p: float) -> float:\n    \"\"\"Return thermal stored energy from pressure and volume.\"\"\"\n    return 1.5 * p_th * V_p\n"}], "Energy confinement time": [{"function": "energy_confinement_time", "module": "fusdb.relations.confinement.plasma_stored_energy", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Energy confinement time\",\n    output=\"tau_E\",\n    variables=(\"W_th\", \"P_loss\"),\n    constraints=(\"P_loss != 0\",),\n)\ndef energy_confinement_time(W_th: float, P_loss: float) -> float:\n    \"\"\"Return energy confinement time from stored energy and loss power.\"\"\"\n    return W_th / P_loss\n"}], "tau_E_hubbard_nominal": [{"function": "tau_E_hubbard_nominal", "module": "fusdb.relations.confinement.scalings", "source": "@Reactor.relation(\n    (\"confinement\", \"tokamak\", \"I-mode\"),\n    name=\"tau_E_hubbard_nominal\",\n    output=\"tau_E\",\n)\ndef tau_E_hubbard_nominal(I_p: float, B0: float, dnla20: float, P_loss: float) -> float:\n    \"\"\"\n        Calculate the Hubbard 2017 I-mode confinement time scaling - nominal\n\n        Parameters:\n        pcur (float): Plasma current [A]\n        b_plasma_toroidal_on_axis (float): Toroidal magnetic field [T]\n        dnla20 (float): Line averaged electron density in units of 10**20 m**-3\n        p_plasma_loss (float): Net Heating power [W]\n\n        Returns:\n        float: Hubbard confinement time [s]\n\n        Notes:\n\n        References:\n            - A. E. Hubbard et al., \u201cPhysics and performance of the I-mode regime over an expanded operating space on Alcator C-Mod,\u201d\n            Nuclear Fusion, vol. 57, no. 12, p. 126039, Oct. 2017, doi: https://doi.org/10.1088/1741-4326/aa8570.\n    \u200c\n    \"\"\"\n    I_p_MA = I_p / 1e6\n    P_loss_MW = P_loss / 1e6\n    return 0.014 * I_p_MA ** 0.68 * B0 ** 0.77 * dnla20 ** 0.02 * P_loss_MW ** (-0.29)\n"}], "tau_E_iter_ipb98y2": [{"function": "tau_E_iter_ipb98y2", "module": "fusdb.relations.confinement.scalings", "source": "@Reactor.relation(\n    (\"confinement\", \"tokamak\", \"H-mode\"),\n    name=\"tau_E_iter_ipb98y2\",\n    output=\"tau_E\",\n)\ndef tau_E_iter_ipb98y2(\n    I_p: float, B0: float, n_la: float, P_loss: float, R: float, kappa_ipb: float, A: float, afuel: float\n) -> float:\n    \"\"\"\n    Taken from PROCESS codebase.\n    Calculate the IPB98(y,2) ELMy H-mode scaling confinement time\n\n    Parameters:\n    I_p (float): Plasma current [A]\n    B0 (float): Toroidal magnetic field on axis[T]\n    n_la (float): Line averaged electron density [m**-3]\n    P_loss (float): Net Heating power [W]\n    R (float): Plasma major radius [m]\n    kappa_ipb (float): IPB specific plasma separatrix elongation\n    A (float): Aspect ratio\n    afuel (float): Fuel atomic mass number\n\n    Returns:\n    float: IPB98(y,2) ELMy H-mode confinement time [s]\n\n    Notes:\n        - See correction paper below for more information about the re-definition of the elongation used.\n\n    References:\n        - I. P. E. G. on C. Transport, I. P. E. G. on C. Database, and I. P. B. Editors, \u201cChapter 2: Plasma confinement and transport,\u201d\n        Nuclear Fusion, vol. 39, no. 12, pp. 2175-2249, Dec. 1999, doi: https://doi.org/10.1088/0029-5515/39/12/302.\n\n        - None Otto Kardaun, N. K. Thomsen, and None Alexander Chudnovskiy, \u201cCorrections to a sequence of papers in Nuclear Fusion,\u201d\n          Nuclear Fusion, vol. 48, no. 9, pp. 099801-099801, Aug. 2008, doi: https://doi.org/10.1088/0029-5515/48/9/099801.\n    \"\"\"\n    return 0.0562 * (I_p / 1e6) ** 0.93 * B0 ** 0.15 * (n_la/1e19) ** 0.41 * (P_loss/1e6)** (-0.69) * R ** 1.97 * kappa_ipb ** 0.78 * A ** (-0.58) * afuel ** 0.19\n"}], "Tokamak surface": [{"function": "plasma_surface_area", "module": "fusdb.relations.geometry", "source": "@Reactor.relation(\n    (\"geometry\", \"tokamak\"),\n    name=\"Tokamak surface\",\n    output=\"S_p\",\n    variables=(\"a\", \"R\", \"kappa\", \"delta\", \"squareness\"),\n    initial_guesses={\n        \"S_p\": lambda v: plasma_surface_area(v[\"a\"], v[\"R\"], v[\"kappa\"], v[\"delta\"], v[\"squareness\"]),\n        \"a\": lambda v: max(1e-3, (abs(v.get(\"S_p\", 1.0)) ** (1 / 2)) / max(v.get(\"kappa\", 1.0), 1e-3)),\n        \"R\": lambda v: max(1e-3, (abs(v.get(\"S_p\", 1.0)) ** (1 / 2))),\n    },\n)\ndef plasma_surface_area(a: float, R: float, kappa: float, delta: float, xi: float) -> float:\n    \"\"\"Return tokamak plasma surface area from geometric shaping parameters.\"\"\"\n    epsilon = a / R\n    theta07 = sp.asin(0.7) + sp.Piecewise(\n        (0, sp.Eq(xi, 0)),\n        ((1 - sp.sqrt(1 + 8 * xi**2)) / (4 * xi), True),\n    )\n    w_07 = sp.cos(theta07 - xi * sp.sin(2 * theta07)) / sp.sqrt(0.51) * (1 - 0.49 / 2 * delta**2)\n    Lp = 2 * sp.pi * a * (1 + 0.55 * (kappa - 1)) * (1 + 0.08 * delta**2) * (1 + 0.2 * (w_07 - 1))\n    return 2 * sp.pi * R * (1 - 0.32 * delta * epsilon) * Lp\n"}, {"function": "plasma_surface_area", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    (\"geometry\", \"tokamak\"),\n    name=\"Tokamak surface\",\n    output=\"S_p\",\n    variables=(\"a\", \"R\", \"kappa\", \"delta\", \"squareness\"),\n    initial_guesses={\n        \"S_p\": lambda v: plasma_surface_area(v[\"a\"], v[\"R\"], v[\"kappa\"], v[\"delta\"], v[\"squareness\"]),\n        \"a\": lambda v: max(1e-3, (abs(v.get(\"S_p\", 1.0)) ** (1 / 2)) / max(v.get(\"kappa\", 1.0), 1e-3)),\n        \"R\": lambda v: max(1e-3, (abs(v.get(\"S_p\", 1.0)) ** (1 / 2))),\n    },\n)\ndef plasma_surface_area(a: float, R: float, kappa: float, delta: float, xi: float) -> float:\n    \"\"\"Return tokamak plasma surface area from geometric shaping parameters.\"\"\"\n    epsilon = a / R\n    theta07 = sp.asin(0.7) + sp.Piecewise(\n        (0, sp.Eq(xi, 0)),\n        ((1 - sp.sqrt(1 + 8 * xi**2)) / (4 * xi), True),\n    )\n    w_07 = sp.cos(theta07 - xi * sp.sin(2 * theta07)) / sp.sqrt(0.51) * (1 - 0.49 / 2 * delta**2)\n    Lp = 2 * sp.pi * a * (1 + 0.55 * (kappa - 1)) * (1 + 0.08 * delta**2) * (1 + 0.2 * (w_07 - 1))\n    return 2 * sp.pi * R * (1 - 0.32 * delta * epsilon) * Lp\n"}], "Tokamak volume": [{"function": "plasma_volume", "module": "fusdb.relations.geometry", "source": "@Reactor.relation(\n    (\"geometry\", \"tokamak\"),\n    name=\"Tokamak volume\",\n    output=\"V_p\",\n    variables=(\"a\", \"R\", \"kappa\", \"delta\", \"squareness\"),\n    initial_guesses={\n        \"V_p\": lambda v: plasma_volume(v[\"a\"], v[\"R\"], v[\"kappa\"], v[\"delta\"], v[\"squareness\"]),\n        \"a\": lambda v: max(1e-3, (abs(v.get(\"V_p\", 1.0)) ** (1 / 3)) / max(v.get(\"kappa\", 1.0), 1e-3)),\n        \"R\": lambda v: max(1e-3, (abs(v.get(\"V_p\", 1.0)) ** (1 / 3)) * max(v.get(\"kappa\", 1.0), 1e-3)),\n    },\n)\ndef plasma_volume(a: float, R: float, kappa: float, delta: float, xi: float) -> float:\n    \"\"\"Return tokamak plasma volume from geometric shaping parameters.\"\"\"\n    epsilon = a / R\n    theta07 = sp.asin(0.7) + sp.Piecewise(\n        (0, sp.Eq(xi, 0)),\n        ((1 - sp.sqrt(1 + 8 * xi**2)) / (4 * xi), True),\n    )\n    w_07 = sp.cos(theta07 - xi * sp.sin(2 * theta07)) / sp.sqrt(0.51) * (1 - 0.49 / 2 * delta**2)\n    S_phi = sp.pi * a**2 * kappa * (1 + 0.52 * (w_07 - 1))\n    return 2 * sp.pi * R * (1 - 0.25 * delta * epsilon) * S_phi\n"}, {"function": "plasma_volume", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    (\"geometry\", \"tokamak\"),\n    name=\"Tokamak volume\",\n    output=\"V_p\",\n    variables=(\"a\", \"R\", \"kappa\", \"delta\", \"squareness\"),\n    initial_guesses={\n        \"V_p\": lambda v: plasma_volume(v[\"a\"], v[\"R\"], v[\"kappa\"], v[\"delta\"], v[\"squareness\"]),\n        \"a\": lambda v: max(1e-3, (abs(v.get(\"V_p\", 1.0)) ** (1 / 3)) / max(v.get(\"kappa\", 1.0), 1e-3)),\n        \"R\": lambda v: max(1e-3, (abs(v.get(\"V_p\", 1.0)) ** (1 / 3)) * max(v.get(\"kappa\", 1.0), 1e-3)),\n    },\n)\ndef plasma_volume(a: float, R: float, kappa: float, delta: float, xi: float) -> float:\n    \"\"\"Return tokamak plasma volume from geometric shaping parameters.\"\"\"\n    epsilon = a / R\n    theta07 = sp.asin(0.7) + sp.Piecewise(\n        (0, sp.Eq(xi, 0)),\n        ((1 - sp.sqrt(1 + 8 * xi**2)) / (4 * xi), True),\n    )\n    w_07 = sp.cos(theta07 - xi * sp.sin(2 * theta07)) / sp.sqrt(0.51) * (1 - 0.49 / 2 * delta**2)\n    S_phi = sp.pi * a**2 * kappa * (1 + 0.52 * (w_07 - 1))\n    return 2 * sp.pi * R * (1 - 0.25 * delta * epsilon) * S_phi\n"}], "Major radius": [{"function": "major_radius", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    \"geometry\",\n    name=\"Major radius\",\n    output=\"R\",\n    initial_guesses={\n        \"R\": lambda v: (v[\"R_max\"] + v[\"R_min\"]) / 2,\n        \"R_max\": lambda v: 2 * v[\"R\"] - v[\"R_min\"],\n        \"R_min\": lambda v: 2 * v[\"R\"] - v[\"R_max\"],\n    },\n)\ndef major_radius(R_max: float, R_min: float) -> float:\n    \"\"\"Return the average major radius from inboard/outboard extents.\"\"\"\n    return (R_max + R_min) / 2\n"}], "Aspect ratio": [{"function": "aspect_ratio", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    \"geometry\",\n    name=\"Aspect ratio\",\n    output=\"A\",\n    constraints=(\"a != 0\", \"R > a\"),\n    initial_guesses={\n        \"A\": lambda v: v[\"R\"] / v[\"a\"],\n        \"R\": lambda v: v[\"A\"] * v[\"a\"],\n        \"a\": lambda v: v[\"R\"] / v[\"A\"],\n    },\n)\ndef aspect_ratio(R: float, a: float) -> float:\n    \"\"\"Return aspect ratio from major and minor radius.\"\"\"\n    return R / a\n"}], "Elongation": [{"function": "elongation", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    \"geometry\",\n    name=\"Elongation\",\n    output=\"kappa\",\n    constraints=(\"R_max - R_min != 0\",\"Z_max - Z_min != 0\"),\n    initial_guesses={\n        \"kappa\": lambda v: (v[\"Z_max\"] - v[\"Z_min\"]) / (v[\"R_max\"] - v[\"R_min\"]),\n        \"Z_max\": lambda v: v[\"Z_min\"] + v[\"kappa\"] * (v[\"R_max\"] - v[\"R_min\"]),\n        \"Z_min\": lambda v: v[\"Z_max\"] - v[\"kappa\"] * (v[\"R_max\"] - v[\"R_min\"]),\n        \"R_max\": lambda v: v[\"R_min\"] + (v[\"Z_max\"] - v[\"Z_min\"]) / v[\"kappa\"],\n        \"R_min\": lambda v: v[\"R_max\"] - (v[\"Z_max\"] - v[\"Z_min\"]) / v[\"kappa\"],\n    },\n)\ndef elongation(Z_max: float, Z_min: float, R_max: float, R_min: float) -> float:\n    \"\"\"Return elongation from vertical and horizontal extents.\"\"\"\n    return (Z_max - Z_min) / (R_max - R_min)\n"}], "Elongation 95%": [{"function": "elongation_95", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    (\"geometry\", \"tokamak\"),\n    name=\"Elongation 95%\",\n    output=\"kappa\",\n    initial_guesses={\"kappa\": lambda v: 1.12 * v[\"kappa_95\"], \"kappa_95\": lambda v: v[\"kappa\"] / 1.12},\n)\ndef elongation_95(kappa_95: float) -> float:\n    \"\"\"Return core elongation from kappa_95.\n    N.A. Uckan and ITER Physics Group, ITER Physics Design Guidelines: 1989, ITER Documentation Series, No. 10, IAEA/ITER/DS/10 (1990)\n    \"\"\"\n    return 1.12 * kappa_95\n"}], "Triangularity 95%": [{"function": "triangularity_95", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    (\"geometry\", \"tokamak\"),\n    name=\"Triangularity 95%\",\n    output=\"delta\",\n    initial_guesses={\"delta\": lambda v: 1.5 * v[\"delta_95\"], \"delta_95\": lambda v: v[\"delta\"] / 1.5},\n)\ndef triangularity_95(delta_95: float) -> float:\n    \"\"\"Return core triangularity from delta_95.\n    N.A. Uckan and ITER Physics Group, ITER Physics Design Guidelines: 1989, ITER Documentation Series, No. 10, IAEA/ITER/DS/10 (1990)\n    \"\"\"\n    return 1.5 * delta_95\n"}], "IPB elongation from volume": [{"function": "kappa_ipb_from_volume", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    \"geometry\",\n    name=\"IPB elongation from volume\",\n    output=\"kappa_ipb\",\n    variables=(\"V_p\", \"R\", \"a\"),\n    constraints=(\"R != 0\", \"a != 0\"),\n)\ndef kappa_ipb_from_volume(V_p: float, R: float, a: float) -> float:\n    \"\"\"Return IPB-specific elongation from volume and radii.\"\"\"\n    return V_p / (2 * sp.pi**2 * R * a**2)\n"}], "ST elongation vs aspect ratio": [{"function": "st_elongation_from_aspect_ratio", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    (\"geometry\", \"spherical_tokamak\"),\n    name=\"ST elongation vs aspect ratio\",\n    output=\"kappa\",\n    initial_guesses={\"kappa\": lambda v: 2.0},\n)\ndef st_elongation_from_aspect_ratio(A: float) -> float:\n    \"\"\"Return spherical tokamak elongation from aspect ratio.\"\"\"\n    return 0.95 * (1.9 + 1.9 / (A ** 1.4))\n"}], "ST triangularity vs aspect ratio": [{"function": "st_triangularity_from_aspect_ratio", "module": "fusdb.relations.geometry.plasma_geometry", "source": "@Reactor.relation(\n    (\"geometry\", \"spherical_tokamak\"),\n    name=\"ST triangularity vs aspect ratio\",\n    output=\"delta\",\n    initial_guesses={\"delta\": lambda v: 0.3},\n)\ndef st_triangularity_from_aspect_ratio(A: float) -> float:\n    \"\"\"Return spherical tokamak triangularity from aspect ratio.\"\"\"\n    return 0.53 * (1 + 0.77 * (1 / A) ** 3) / 1.50\n"}], "Troyon beta limit": [{"function": "troyon_beta_limit", "module": "fusdb.relations.operational_limits.beta_limits", "source": "@Reactor.relation(\n    (\"plasma\", \"tokamak\"),\n    name=\"Troyon beta limit\",\n    output=\"beta_limit\",\n    constraints=(\"a != 0\", \"B0 != 0\", \"I_p != 0\"),\n)\ndef troyon_beta_limit(a: float, B0: float, I_p: float) -> float:\n    \"\"\"Approximate Troyon limit: beta (fraction) = 0.028 * I_p / (a * B0).\"\"\"\n    I_p_MA = I_p / 1e6\n    return 0.028 * I_p_MA / (a * B0)\n"}], "Greenwald density limit": [{"function": "greenwald_density_limit", "module": "fusdb.relations.operational_limits.density_limits", "source": "@Reactor.relation(\n    (\"plasma\", \"tokamak\"),\n    name=\"Greenwald density limit\",\n    output=\"n_GW\",\n    constraints=(\"a != 0\"),\n)\ndef greenwald_density_limit(I_p: float, a: float) -> float:\n    \"\"\"Return Greenwald density limit in 1/m^3 for tokamaks.\"\"\"\n    I_p_MA = I_p / 1e6\n    return 1e20 * I_p_MA / (sp.pi * a**2)\n"}], "Greenwald density fraction": [{"function": "greenwald_density_fraction", "module": "fusdb.relations.operational_limits.density_limits", "source": "@Reactor.relation(\n    (\"plasma\", \"tokamak\"),\n    name=\"Greenwald density fraction\",\n    output=\"f_GW\", # type: ignore[arg-type]\n    constraints=(\"n_GW != 0\",)\n)\ndef greenwald_density_fraction(n_GW: float, n_avg: float) -> float:\n    \"\"\"Return fraction of Greenwald density limit.\"\"\"\n    f_GW =  n_avg / n_GW\n    return f_GW\n"}], "Sudo density limit": [{"function": "sudo_density_limit", "module": "fusdb.relations.operational_limits.density_limits", "source": "@Reactor.relation(\n    (\"plasma\", \"stellarator\"),\n    name=\"Sudo density limit\",\n    output=\"n_SUDO\",\n    constraints=(\"R != 0\", \"a != 0\"),\n)\ndef sudo_density_limit(P_loss: float, B0: float, R: float, a: float) -> float:\n    \"\"\"Return Sudo density limit in 1/m^3 for stellarators.\"\"\"\n    P_loss_MW = P_loss / 1e6\n    return 1e20 * 0.25 * P_loss_MW * B0 / (R * a**2)\n"}], "Average fuel mass number": [{"function": "average_fuel_mass_number", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Average fuel mass number\",\n    output=\"afuel\",\n)\ndef average_fuel_mass_number(f_D: float, f_T: float, f_He3: float, f_He4: float) -> float:\n    \"\"\"Return average ion mass number from ion fractions.\"\"\"\n    return 2.0 * f_D + 3.0 * f_T + 3.0 * f_He3 + 4.0 * f_He4\n# TODO(low): improve it to work automatically by taking data from allowed_species\n\n\n# TODO(med): could add a relation to evaluate D, T, He3 injection terms at steady-state\n    # Ndot_inj_x = V_p*(n_x/tau_p_x - n_x_production + n_x_burn)\n"}, {"function": "average_fuel_mass_number", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Average fuel mass number\",\n    output=\"afuel\",\n)\ndef average_fuel_mass_number(f_D: float, f_T: float, f_He3: float, f_He4: float) -> float:\n    \"\"\"Return average ion mass number from ion fractions.\"\"\"\n    return 2.0 * f_D + 3.0 * f_T + 3.0 * f_He3 + 4.0 * f_He4\n# TODO(low): improve it to work automatically by taking data from allowed_species\n\n\n# TODO(med): could add a relation to evaluate D, T, He3 injection terms at steady-state\n    # Ndot_inj_x = V_p*(n_x/tau_p_x - n_x_production + n_x_burn)\n"}], "Deuterium density from fraction": [{"function": "deuterium_density", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Deuterium density from fraction\",\n    output=\"n_D\",\n)\ndef deuterium_density(f_D: float, n_i: float) -> float:\n    \"\"\"Return deuterium density from ion fraction and total ion density.\"\"\"\n    return f_D * n_i\n"}, {"function": "deuterium_density", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Deuterium density from fraction\",\n    output=\"n_D\",\n)\ndef deuterium_density(f_D: float, n_i: float) -> float:\n    \"\"\"Return deuterium density from ion fraction and total ion density.\"\"\"\n    return f_D * n_i\n"}], "Deuterium fraction from density": [{"function": "deuterium_fraction", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Deuterium fraction from density\",\n    output=\"f_D\",\n    constraints=(\"n_i > 0\",),\n)\ndef deuterium_fraction(n_D: float, n_i: float) -> float:\n    \"\"\"Return deuterium fraction from density and total ion density.\"\"\"\n    return n_D / n_i\n"}, {"function": "deuterium_fraction", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Deuterium fraction from density\",\n    output=\"f_D\",\n    constraints=(\"n_i > 0\",),\n)\ndef deuterium_fraction(n_D: float, n_i: float) -> float:\n    \"\"\"Return deuterium fraction from density and total ion density.\"\"\"\n    return n_D / n_i\n"}], "Ion fraction normalization (solve f_D)": [{"function": "deuterium_fraction_normalized", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Ion fraction normalization (solve f_D)\",\n    output=\"f_D\",\n)\ndef deuterium_fraction_normalized(f_T: float, f_He3: float, f_He4: float) -> float:\n    \"\"\"Return deuterium fraction from the ion fraction normalization.\"\"\"\n    return 1.0 - f_T - f_He3 - f_He4\n"}, {"function": "deuterium_fraction_normalized", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Ion fraction normalization (solve f_D)\",\n    output=\"f_D\",\n)\ndef deuterium_fraction_normalized(f_T: float, f_He3: float, f_He4: float) -> float:\n    \"\"\"Return deuterium fraction from the ion fraction normalization.\"\"\"\n    return 1.0 - f_T - f_He3 - f_He4\n"}], "Electron density from volume-averaged density": [{"function": "electron_density_from_average", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Electron density from volume-averaged density\",\n    output=\"n_e\",\n    variables=(\"n_avg\",),\n)\ndef electron_density_from_average(n_avg: float) -> float:\n    \"\"\"Return electron density from volume-averaged density.\"\"\"\n    return n_avg\n"}, {"function": "electron_density_from_average", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Electron density from volume-averaged density\",\n    output=\"n_e\",\n    variables=(\"n_avg\",),\n)\ndef electron_density_from_average(n_avg: float) -> float:\n    \"\"\"Return electron density from volume-averaged density.\"\"\"\n    return n_avg\n"}], "Electron density from ion fractions": [{"function": "electron_density_from_fractions", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Electron density from ion fractions\",\n    output=\"n_e\",\n)\ndef electron_density_from_fractions(\n    n_i: float,\n    f_D: float,\n    f_T: float,\n    f_He3: float,\n    f_He4: float,\n) -> float:\n    \"\"\"Return electron density from ion density and ion fractions.\"\"\"\n    return n_i * (f_D + f_T + 2.0 * f_He3 + 2.0 * f_He4)\n"}, {"function": "electron_density_from_fractions", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Electron density from ion fractions\",\n    output=\"n_e\",\n)\ndef electron_density_from_fractions(\n    n_i: float,\n    f_D: float,\n    f_T: float,\n    f_He3: float,\n    f_He4: float,\n) -> float:\n    \"\"\"Return electron density from ion density and ion fractions.\"\"\"\n    return n_i * (f_D + f_T + 2.0 * f_He3 + 2.0 * f_He4)\n"}], "Helium-3 density from fraction": [{"function": "helium3_density", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Helium-3 density from fraction\",\n    output=\"n_He3\",\n)\ndef helium3_density(f_He3: float, n_i: float) -> float:\n    \"\"\"Return helium-3 density from ion fraction and total ion density.\"\"\"\n    return f_He3 * n_i\n"}, {"function": "helium3_density", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Helium-3 density from fraction\",\n    output=\"n_He3\",\n)\ndef helium3_density(f_He3: float, n_i: float) -> float:\n    \"\"\"Return helium-3 density from ion fraction and total ion density.\"\"\"\n    return f_He3 * n_i\n"}], "Helium-3 fraction from density": [{"function": "helium3_fraction", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Helium-3 fraction from density\",\n    output=\"f_He3\",\n    constraints=(\"n_i > 0\",),\n)\ndef helium3_fraction(n_He3: float, n_i: float) -> float:\n    \"\"\"Return helium-3 fraction from density and total ion density.\"\"\"\n    return n_He3 / n_i\n"}, {"function": "helium3_fraction", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Helium-3 fraction from density\",\n    output=\"f_He3\",\n    constraints=(\"n_i > 0\",),\n)\ndef helium3_fraction(n_He3: float, n_i: float) -> float:\n    \"\"\"Return helium-3 fraction from density and total ion density.\"\"\"\n    return n_He3 / n_i\n"}], "Ion fraction normalization (solve f_He3)": [{"function": "helium3_fraction_normalized", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Ion fraction normalization (solve f_He3)\",\n    output=\"f_He3\",\n)\ndef helium3_fraction_normalized(f_D: float, f_T: float, f_He4: float) -> float:\n    \"\"\"Return helium-3 fraction from the ion fraction normalization.\"\"\"\n    return 1.0 - f_D - f_T - f_He4\n"}, {"function": "helium3_fraction_normalized", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Ion fraction normalization (solve f_He3)\",\n    output=\"f_He3\",\n)\ndef helium3_fraction_normalized(f_D: float, f_T: float, f_He4: float) -> float:\n    \"\"\"Return helium-3 fraction from the ion fraction normalization.\"\"\"\n    return 1.0 - f_D - f_T - f_He4\n"}], "Helium-4 density from fraction": [{"function": "helium4_density", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Helium-4 density from fraction\",\n    output=\"n_He4\",\n)\ndef helium4_density(f_He4: float, n_i: float) -> float:\n    \"\"\"Return helium-4 density from ion fraction and total ion density.\"\"\"\n    return f_He4 * n_i\n"}, {"function": "helium4_density", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Helium-4 density from fraction\",\n    output=\"n_He4\",\n)\ndef helium4_density(f_He4: float, n_i: float) -> float:\n    \"\"\"Return helium-4 density from ion fraction and total ion density.\"\"\"\n    return f_He4 * n_i\n"}], "Helium-4 fraction from density": [{"function": "helium4_fraction", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Helium-4 fraction from density\",\n    output=\"f_He4\",\n    constraints=(\"n_i > 0\",),\n)\ndef helium4_fraction(n_He4: float, n_i: float) -> float:\n    \"\"\"Return helium-4 fraction from density and total ion density.\"\"\"\n    return n_He4 / n_i\n"}, {"function": "helium4_fraction", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Helium-4 fraction from density\",\n    output=\"f_He4\",\n    constraints=(\"n_i > 0\",),\n)\ndef helium4_fraction(n_He4: float, n_i: float) -> float:\n    \"\"\"Return helium-4 fraction from density and total ion density.\"\"\"\n    return n_He4 / n_i\n"}], "Ion fraction normalization (solve f_He4)": [{"function": "helium4_fraction_normalized", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Ion fraction normalization (solve f_He4)\",\n    output=\"f_He4\",\n)\ndef helium4_fraction_normalized(f_D: float, f_T: float, f_He3: float) -> float:\n    \"\"\"Return helium-4 fraction from the ion fraction normalization.\"\"\"\n    return 1.0 - f_D - f_T - f_He3\n"}, {"function": "helium4_fraction_normalized", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Ion fraction normalization (solve f_He4)\",\n    output=\"f_He4\",\n)\ndef helium4_fraction_normalized(f_D: float, f_T: float, f_He3: float) -> float:\n    \"\"\"Return helium-4 fraction from the ion fraction normalization.\"\"\"\n    return 1.0 - f_D - f_T - f_He3\n"}], "Tritium density from fraction": [{"function": "tritium_density", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Tritium density from fraction\",\n    output=\"n_T\",\n)\ndef tritium_density(f_T: float, n_i: float) -> float:\n    \"\"\"Return tritium density from ion fraction and total ion density.\"\"\"\n    return f_T * n_i\n"}, {"function": "tritium_density", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Tritium density from fraction\",\n    output=\"n_T\",\n)\ndef tritium_density(f_T: float, n_i: float) -> float:\n    \"\"\"Return tritium density from ion fraction and total ion density.\"\"\"\n    return f_T * n_i\n"}], "Tritium fraction from density": [{"function": "tritium_fraction", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Tritium fraction from density\",\n    output=\"f_T\",\n    constraints=(\"n_i > 0\",),\n)\ndef tritium_fraction(n_T: float, n_i: float) -> float:\n    \"\"\"Return tritium fraction from density and total ion density.\"\"\"\n    return n_T / n_i\n"}, {"function": "tritium_fraction", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Tritium fraction from density\",\n    output=\"f_T\",\n    constraints=(\"n_i > 0\",),\n)\ndef tritium_fraction(n_T: float, n_i: float) -> float:\n    \"\"\"Return tritium fraction from density and total ion density.\"\"\"\n    return n_T / n_i\n"}], "Ion fraction normalization (solve f_T)": [{"function": "tritium_fraction_normalized", "module": "fusdb.relations.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Ion fraction normalization (solve f_T)\",\n    output=\"f_T\",\n)\ndef tritium_fraction_normalized(f_D: float, f_He3: float, f_He4: float) -> float:\n    \"\"\"Return tritium fraction from the ion fraction normalization.\"\"\"\n    return 1.0 - f_D - f_He3 - f_He4\n"}, {"function": "tritium_fraction_normalized", "module": "fusdb.relations.plasma_composition.plasma_composition", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Ion fraction normalization (solve f_T)\",\n    output=\"f_T\",\n)\ndef tritium_fraction_normalized(f_D: float, f_He3: float, f_He4: float) -> float:\n    \"\"\"Return tritium fraction from the ion fraction normalization.\"\"\"\n    return 1.0 - f_D - f_He3 - f_He4\n"}], "Toroidal beta": [{"function": "toroidal_beta", "module": "fusdb.relations.plasma_pressure.beta", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Toroidal beta\",\n    output=\"beta_T\",\n    constraints=(\"B0 != 0\"),\n)\ndef toroidal_beta(p_th: float, B0: float) -> float:\n    \"\"\"Freidberg Eq. 11.58: toroidal field contribution (dimensionless).\"\"\"\n    return (2 * MU0 * p_th) / (B0 ** 2)\n"}], "Poloidal beta": [{"function": "poloidal_beta", "module": "fusdb.relations.plasma_pressure.beta", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Poloidal beta\",\n    output=\"beta_p\",\n    constraints=(\"B_p != 0\"),\n)\ndef poloidal_beta(p_th: float, B_p: float) -> float:\n    \"\"\"Freidberg Eq. 11.58 using poloidal field magnitude.\"\"\"\n    return (2 * MU0 * p_th) / (B_p ** 2)\n"}], "Beta decomposition": [{"function": "beta_decomposition", "module": "fusdb.relations.plasma_pressure.beta", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Beta decomposition\",\n    output=\"beta\",\n    constraints=(\"beta_T != 0\", \"beta_p != 0\"),\n)\ndef beta_decomposition(beta_T: float, beta_p: float) -> float:\n    \"\"\"Total beta from toroidal and poloidal components (Freidberg Eq. 11.59).\"\"\"\n    return 1 / (1 / beta_T + 1 / beta_p)\n"}], "Normalized beta": [{"function": "normalized_beta", "module": "fusdb.relations.plasma_pressure.beta", "source": "@Reactor.relation(\n    \"plasma\",\n    name=\"Normalized beta\",\n    output=\"beta_N\",\n    constraints=(\"I_p != 0\")\n)\ndef normalized_beta(beta_T: float, a: float, B0: float, I_p: float) -> float:\n    \"\"\"Wesson/Troyon normalization: beta_N = beta_T(%) * a * B0 / I_p.\"\"\"\n    # beta_T is a fraction; convert to % with factor 100 for standard beta_N definition.\n    I_p_MA = I_p / 1e6\n    return beta_T * 100.0 * a * B0 / I_p_MA\n"}], "Thermal pressure": [{"function": "thermal_pressure", "module": "fusdb.relations.plasma_pressure.plasma_pressure", "source": "@Reactor.relation(\"plasma\", name=\"Thermal pressure\", output=\"p_th\")\ndef thermal_pressure(n_e: float, T_e: float, n_i: float, T_i: float) -> float:\n    \"\"\"Return thermal pressure from electron/ion densities and temperatures.\"\"\"\n    return (n_e * T_e + n_i * T_i) * KEV_TO_J\n"}], "Peak pressure": [{"function": "peak_pressure", "module": "fusdb.relations.plasma_pressure.plasma_pressure", "source": "@Reactor.relation(\"plasma\", name=\"Peak pressure\", output=\"p_peak\")\ndef peak_pressure(n0: float, T0: float, n_i_peak: float, T_i_peak: float) -> float:\n    \"\"\"Calculate the peak pressure.\"\"\"\n    return (n0 * T0 + n_i_peak * T_i_peak) * KEV_TO_J\n"}], "Total auxiliary power": [{"function": "auxiliary_power", "module": "fusdb.relations.power_balance.auxiliary_power.auxiliary_power", "source": "@Reactor.relation(\n    (\"power_exhaust\", \"auxiliary\"),\n    name=\"Total auxiliary power\",\n    output=\"P_aux\",\n)\ndef auxiliary_power(P_NBI: float, P_ICRF: float, P_LHCD: float) -> float:\n    \"\"\"Return total auxiliary power from injected sources.\"\"\"\n    return P_NBI + P_ICRF + P_LHCD\n"}], "Fusion triple product": [{"function": "fusion_triple_product", "module": "fusdb.relations.power_balance.fusion_power.fusion_gain", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"Fusion triple product\",\n    output=\"n_i_tau_E_T_i\",\n)\ndef fusion_triple_product(\n    n_i_peak: float, T_i_peak: float, tau_E: float\n) -> float:\n    \"\"\"Return fusion triple product from peak ion density, peak ion temperature, and energy confinement time.\n\n    The fusion triple product (n_i * T_i * tau_E) is a key figure of merit for fusion performance,\n    representing the combined effect of density, temperature, and confinement.\n\n    Args:\n        n_i_peak: Peak fuel ion density [m^-3]\n        T_i_peak: Peak ion temperature [keV]\n        tau_E: Energy confinement time [s]\n\n    Returns:\n        n_i_tau_E_T_i: Fusion triple product [m^-3 keV s]\n    \"\"\"\n    return n_i_peak * T_i_peak * tau_E\n"}], "Physics gain factor": [{"function": "physics_gain_factor", "module": "fusdb.relations.power_balance.fusion_power.fusion_gain", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"Physics gain factor\",\n    output=\"Q_sci\",\n)\ndef physics_gain_factor(\n    P_fus: float, P_aux: float) -> float:\n    \"\"\"Return the physics gain factor Q_phy = (P_fus / P_aux) for fusion power.\n\n    The physics gain factor is a measure of the fusion power output relative to the ABSORBED auxiliary power.\n    - Scientifc Breakeven: Q_phy = 1 \n    - Burning plasma: Q_phy >= 5 (at Q = 5 P_alpha = P_aux in DT fusion)\n    - Ignition: Q_phy -> infinity (P_aux = 0)\n    Args:\n        P_fus: Fusion power [W]\n        P_aux: Auxiliary power [W]\n\n    Returns:\n        physics_gain_factor: Physics gain factor [dimensionless]\n    \"\"\"\n    if P_aux == 0:\n        Q_phy = np.inf\n    else:\n        Q_phy = P_fus / P_aux\n    return Q_phy\n"}], "Engineering gain factor": [{"function": "engineering_gain_factor", "module": "fusdb.relations.power_balance.fusion_power.fusion_gain", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"Engineering gain factor\",\n    output=\"Q_eng\",\n)\ndef engineering_gain_factor(\n    P_fus_el: float, P_aux_el: float) -> float:\n    \"\"\"Return the engineering gain factor Q_eng = (P_fus_el / P_aux_el).\n\n    The engineering gain factor is a measure of the net electric power output relative to the electrical power required to drive external heating sources.\n    \"\"\"\n    if P_aux_el == 0 and P_fus_el > 0:\n        Q_eng = np.inf\n    else:\n        Q_eng = (P_fus_el - P_aux_el) / P_aux_el\n    return Q_eng\n"}], "Total fusion power": [{"function": "fusion_power_total", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"Total fusion power\",\n    output=\"P_fus\",\n    constraints=(\"P_fus >= 0\",),\n)\ndef fusion_power_total(\n    P_fus_DT: float,\n    P_fus_DD: float,\n    P_fus_DHe3: float,\n    P_fus_TT: float,\n) -> float:\n    \"\"\"Return total fusion power from DT, DD, D-He3, and TT contributions.\"\"\"\n    return P_fus_DT + P_fus_DD + P_fus_DHe3 + P_fus_TT\n"}], "Charged fusion power": [{"function": "charged_fusion_power", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"Charged fusion power\",\n    output=\"P_charged\",\n)\ndef charged_fusion_power(\n    P_fus_DT_alpha: float,\n    P_fus_DDn_He3: float,\n    P_fus_DDp_T: float,\n    P_fus_DDp_p: float,\n    P_fus_DHe3_alpha: float,\n    P_fus_DHe3_p: float,\n) -> float:\n    \"\"\"Return charged fusion power from common D-T, D-D, and D-He3 channels.\"\"\"\n    return (\n        P_fus_DT_alpha\n        + P_fus_DDn_He3\n        + P_fus_DDp_T\n        + P_fus_DDp_p\n        + P_fus_DHe3_alpha\n        + P_fus_DHe3_p\n    )\n"}], "Neutron fusion power": [{"function": "neutron_fusion_power", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"Neutron fusion power\",\n    output=\"P_neutron\",\n)\ndef neutron_fusion_power(\n    P_fus_DT_n: float,\n    P_fus_DDn_n: float,\n) -> float:\n    \"\"\"Return neutron fusion power from common D-T and D-D channels.\"\"\"\n    return P_fus_DT_n + P_fus_DDn_n\n"}], "DT fusion power": [{"function": "fusion_power_dt", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DT fusion power\",\n    output=\"P_fus_DT\",\n)\ndef fusion_power_dt(P_fus_DT_alpha: float, P_fus_DT_n: float) -> float:\n    \"\"\"Return total D-T fusion power from alpha and neutron components.\"\"\"\n    return P_fus_DT_alpha + P_fus_DT_n\n"}], "DT alpha power": [{"function": "alpha_power_dt", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DT alpha power\",\n    output=\"P_fus_DT_alpha\",\n)\ndef alpha_power_dt(Rr_DT: float) -> float:\n    \"\"\"Return alpha power from D-T fusion.\"\"\"\n    return DT_ALPHA_ENERGY_J * Rr_DT\n"}], "DT neutron power": [{"function": "neutron_power_dt", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DT neutron power\",\n    output=\"P_fus_DT_n\",\n)\ndef neutron_power_dt(Rr_DT: float) -> float:\n    \"\"\"Return neutron power from D-T fusion.\"\"\"\n    return DT_N_ENERGY_J * Rr_DT\n"}], "DD fusion power": [{"function": "fusion_power_dd", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DD fusion power\",\n    output=\"P_fus_DD\",\n)\ndef fusion_power_dd(P_fus_DDn: float, P_fus_DDp: float) -> float:\n    \"\"\"Return total D-D fusion power from both branches.\"\"\"\n    return P_fus_DDn + P_fus_DDp\n"}], "DD (T+p) fusion power": [{"function": "fusion_power_ddp", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DD (T+p) fusion power\",\n    output=\"P_fus_DDp\",\n)\ndef fusion_power_ddp(P_fus_DDp_T: float, P_fus_DDp_p: float) -> float:\n    \"\"\"Return D-D fusion power from the T+p branch.\"\"\"\n    return P_fus_DDp_T + P_fus_DDp_p\n"}], "DD (He3+n) fusion power": [{"function": "fusion_power_ddn", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DD (He3+n) fusion power\",\n    output=\"P_fus_DDn\",\n)\ndef fusion_power_ddn(P_fus_DDn_He3: float, P_fus_DDn_n: float) -> float:\n    \"\"\"Return D-D fusion power from the He3+n branch.\"\"\"\n    return P_fus_DDn_He3 + P_fus_DDn_n\n"}], "DDp triton power": [{"function": "triton_power_dd", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DDp triton power\",\n    output=\"P_fus_DDp_T\",\n)\ndef triton_power_dd(Rr_DDp: float) -> float:\n    \"\"\"Return triton power from the D(d,p)T branch.\"\"\"\n    return DD_T_ENERGY_J * Rr_DDp\n"}], "DDp proton power": [{"function": "proton_power_dd", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DDp proton power\",\n    output=\"P_fus_DDp_p\",\n)\ndef proton_power_dd(Rr_DDp: float) -> float:\n    \"\"\"Return proton power from the D(d,p)T branch.\"\"\"\n    return DD_P_ENERGY_J * Rr_DDp\n"}], "DDn helium-3 power": [{"function": "he3_power_dd", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DDn helium-3 power\",\n    output=\"P_fus_DDn_He3\",\n)\ndef he3_power_dd(Rr_DDn: float) -> float:\n    \"\"\"Return He3 power from the D(d,n)He3 branch.\"\"\"\n    return DD_HE3_ENERGY_J * Rr_DDn\n"}], "DDn neutron power": [{"function": "neutron_power_dd", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DDn neutron power\",\n    output=\"P_fus_DDn_n\",\n)\ndef neutron_power_dd(Rr_DDn: float) -> float:\n    \"\"\"Return neutron power from the D(d,n)He3 branch.\"\"\"\n    return DD_N_ENERGY_J * Rr_DDn\n"}], "D-He3 fusion power": [{"function": "fusion_power_dhe3", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"D-He3 fusion power\",\n    output=\"P_fus_DHe3\",\n)\ndef fusion_power_dhe3(P_fus_DHe3_alpha: float, P_fus_DHe3_p: float) -> float:\n    \"\"\"Return total D-He3 fusion power from alpha and proton components.\"\"\"\n    return P_fus_DHe3_alpha + P_fus_DHe3_p\n"}], "D-He3 alpha power": [{"function": "alpha_power_dhe3", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"D-He3 alpha power\",\n    output=\"P_fus_DHe3_alpha\",\n)\ndef alpha_power_dhe3(Rr_DHe3: float) -> float:\n    \"\"\"Return alpha power from D-He3 fusion.\"\"\"\n    return DHE3_ALPHA_ENERGY_J * Rr_DHe3\n"}], "D-He3 proton power": [{"function": "proton_power_dhe3", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"D-He3 proton power\",\n    output=\"P_fus_DHe3_p\",\n)\ndef proton_power_dhe3(Rr_DHe3: float) -> float:\n    \"\"\"Return proton power from D-He3 fusion.\"\"\"\n    return DHE3_P_ENERGY_J * Rr_DHe3\n"}], "TT fusion power": [{"function": "fusion_power_tt", "module": "fusdb.relations.power_balance.fusion_power.fusion_power", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"TT fusion power\",\n    output=\"P_fus_TT\",\n)\ndef fusion_power_tt(Rr_TT: float) -> float:\n    \"\"\"Return total fusion power from T-T reactions.\"\"\"\n    return TT_REACTION_ENERGY_J * Rr_TT\n"}], "DT reaction rate": [{"function": "reaction_rate_dt", "module": "fusdb.relations.power_balance.fusion_power.reaction_rate", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DT reaction rate\",\n    output=\"Rr_DT\",\n)\ndef reaction_rate_dt(f_D: float, f_T: float, n_i: float, T_avg: float, V_p: float) -> float:\n    \"\"\"Return DT fusion reaction rate from fractions, temperature, and volume.\"\"\"\n    reactivity = sigmav_DT_BoschHale(T_avg)\n    return f_D * f_T * (n_i ** 2) * reactivity * V_p\n"}], "DD (He3+n) reaction rate": [{"function": "reaction_rate_ddn", "module": "fusdb.relations.power_balance.fusion_power.reaction_rate", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DD (He3+n) reaction rate\",\n    output=\"Rr_DDn\",\n)\ndef reaction_rate_ddn(f_D: float, n_i: float, T_avg: float, V_p: float) -> float:\n    \"\"\"Return D(d,n)He3 reaction rate (branch) from fractions, temperature, and volume.\"\"\"\n    _, sigmav_ddn, _ = sigmav_DD_BoschHale(T_avg)\n    return 0.5 * (f_D ** 2) * (n_i ** 2) * sigmav_ddn * V_p\n"}], "DD (T+p) reaction rate": [{"function": "reaction_rate_ddp", "module": "fusdb.relations.power_balance.fusion_power.reaction_rate", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"DD (T+p) reaction rate\",\n    output=\"Rr_DDp\",\n)\ndef reaction_rate_ddp(f_D: float, n_i: float, T_avg: float, V_p: float) -> float:\n    \"\"\"Return D(d,p)T reaction rate (branch) from fractions, temperature, and volume.\"\"\"\n    _, _, sigmav_ddp = sigmav_DD_BoschHale(T_avg)\n    return 0.5 * (f_D ** 2) * (n_i ** 2) * sigmav_ddp * V_p\n"}], "D-He3 reaction rate": [{"function": "reaction_rate_dhe3", "module": "fusdb.relations.power_balance.fusion_power.reaction_rate", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"D-He3 reaction rate\",\n    output=\"Rr_DHe3\",\n)\ndef reaction_rate_dhe3(f_D: float, f_He3: float, n_i: float, T_avg: float, V_p: float) -> float:\n    \"\"\"Return D-He3 fusion reaction rate from fractions, temperature, and volume.\"\"\"\n    reactivity = sigmav_DHe3_BoschHale(T_avg)\n    return f_D * f_He3 * (n_i ** 2) * reactivity * V_p\n"}], "T-T reaction rate": [{"function": "reaction_rate_tt", "module": "fusdb.relations.power_balance.fusion_power.reaction_rate", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"T-T reaction rate\",\n    output=\"Rr_TT\",\n)\ndef reaction_rate_tt(f_T: float, n_i: float, T_avg: float, V_p: float) -> float:\n    \"\"\"Return T-T fusion reaction rate from fractions, temperature, and volume.\"\"\"\n    reactivity = sigmav_TT(T_avg)\n    return 0.5 * (f_T ** 2) * (n_i ** 2) * reactivity * V_p\n"}], "He3-He3 reaction rate": [{"function": "reaction_rate_he3he3", "module": "fusdb.relations.power_balance.fusion_power.reaction_rate", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"He3-He3 reaction rate\",\n    output=\"Rr_He3He3\",\n)\ndef reaction_rate_he3he3(f_He3: float, n_i: float, T_avg: float, V_p: float) -> float:\n    \"\"\"Return He3-He3 fusion reaction rate from fractions, temperature, and volume.\"\"\"\n    reactivity = sigmav_He3He3(T_avg)\n    return 0.5 * (f_He3 ** 2) * (n_i ** 2) * reactivity * V_p\n"}], "T-He3 reaction rate": [{"function": "reaction_rate_the3", "module": "fusdb.relations.power_balance.fusion_power.reaction_rate", "source": "@Reactor.relation(\n    \"fusion_power\",\n    name=\"T-He3 reaction rate\",\n    output=\"Rr_THe3\",\n)\ndef reaction_rate_the3(f_T: float, f_He3: float, n_i: float, T_avg: float, V_p: float) -> float:\n    \"\"\"Return T-He3 fusion reaction rate from fractions, temperature, and volume.\"\"\"\n    reactivity = sigmav_THe3(T_avg)\n    return f_T * f_He3 * (n_i ** 2) * reactivity * V_p\n"}], "Total plasma heating": [{"function": "total_plasma_heating", "module": "fusdb.relations.power_balance.power_balance", "source": "@Reactor.relation(\n    \"power_balance\",\n    name=\"Total plasma heating\",\n    output=\"P_heating\",\n)\ndef total_plasma_heating(P_ohmic: float, P_charged: float, P_aux: float) -> float:\n    \"\"\"Return total plasma heating from ohmic, charged fusion, and auxiliary sources.\"\"\"\n    return P_ohmic + P_charged + P_aux\n"}], "Loss power to SOL and core radiation": [{"function": "loss_power_to_exhaust", "module": "fusdb.relations.power_balance.power_balance", "source": "@Reactor.relation(\n    \"power_balance\",\n    name=\"Loss power to SOL and core radiation\",\n    output=\"P_loss_explicit\",\n)\ndef loss_power_to_exhaust(P_sep: float, P_rad: float) -> float:\n    \"\"\"Return loss power as the sum of separatrix power and core radiation.\"\"\"\n    return P_sep + P_rad\n"}], "Power balance": [{"function": "power_balance_simple", "module": "fusdb.relations.power_balance.power_balance", "source": "@Reactor.relation(\n    \"power_balance\",\n    name=\"Power balance\",\n    output=\"P_loss\",\n)\ndef power_balance_simple(P_heating: float) -> float:\n    \"\"\"Total power lost must equal total power input.\"\"\"\n    return P_heating\n"}], "P_sep ratio": [{"function": "p_sep_ratio", "module": "fusdb.relations.power_balance.power_exhaust.power_exhaust", "source": "@Reactor.relation(\n    \"power_exhaust\",\n    name=\"P_sep ratio\",\n    output=\"P_sep_over_R\",\n    constraints=(\"R != 0\"),\n    initial_guesses={\n        \"P_sep_over_R\": lambda v: v[\"P_sep\"] / v[\"R\"],\n        \"P_sep\": lambda v: v[\"P_sep_over_R\"] * v[\"R\"],\n        \"R\": lambda v: v[\"P_sep\"] / v[\"P_sep_over_R\"],\n    },\n)\ndef p_sep_ratio(P_sep: float, R: float) -> float:\n    \"\"\"Return the P_sep / R ratio.\"\"\"\n    return P_sep / R\n"}], "P_sep metric": [{"function": "p_sep_metric", "module": "fusdb.relations.power_balance.power_exhaust.power_exhaust", "source": "@Reactor.relation(\n    \"power_exhaust\",\n    name=\"P_sep metric\",\n    output=\"P_sep_B_over_q95AR\",\n    constraints=(\"q95 != 0\", \"A != 0\", \"R != 0\"),\n    initial_guesses={\n        \"P_sep_B_over_q95AR\": lambda v: v[\"P_sep\"] * v[\"B0\"] / (v[\"q95\"] * v[\"A\"] * v[\"R\"]),\n        \"P_sep\": lambda v: v[\"P_sep_B_over_q95AR\"] * v[\"q95\"] * v[\"A\"] * v[\"R\"] / v[\"B0\"],\n        \"B0\": lambda v: v[\"P_sep_B_over_q95AR\"] * v[\"q95\"] * v[\"A\"] * v[\"R\"] / v[\"P_sep\"],\n        \"q95\": lambda v: v[\"P_sep\"] * v[\"B0\"] / (v[\"P_sep_B_over_q95AR\"] * v[\"A\"] * v[\"R\"]),\n        \"A\": lambda v: v[\"P_sep\"] * v[\"B0\"] / (v[\"P_sep_B_over_q95AR\"] * v[\"q95\"] * v[\"R\"]),\n        \"R\": lambda v: v[\"P_sep\"] * v[\"B0\"] / (v[\"P_sep_B_over_q95AR\"] * v[\"q95\"] * v[\"A\"]),\n    },\n)\ndef p_sep_metric(P_sep: float, B0: float, q95: float, A: float, R: float) -> float:\n    \"\"\"Return the P_sep * B0 / (q95 * A * R) metric.\"\"\"\n    return P_sep * B0 / (q95 * A * R)\n\n\n# TODO(high): add relations for P_fus_wall and P_n_wall\n    # to do this, add a S_wall variable that defaults to S_p if not specified\n    \n# TODO(low): cfspopcon adds \n    # P_sep*B0/R0, which scales roughly the same as the parallel heat flux density entering the scrape-off-layer.\n    # P_sep * B_pol / (R * n^2), which scales roughly the same as the impurity fraction required for detachment.\n"}]};
window.varConnections = {"A": {"produced_by": ["Aspect ratio"], "used_by": ["P_sep metric", "ST elongation vs aspect ratio", "ST triangularity vs aspect ratio", "tau_E_iter_ipb98y2"]}, "B0": {"produced_by": [], "used_by": ["Normalized beta", "P_sep metric", "Sudo density limit", "Toroidal beta", "Troyon beta limit", "tau_E_hubbard_nominal", "tau_E_iter_ipb98y2"]}, "B_p": {"produced_by": [], "used_by": ["Poloidal beta"]}, "I_p": {"produced_by": [], "used_by": ["Greenwald density limit", "Normalized beta", "Troyon beta limit", "tau_E_hubbard_nominal", "tau_E_iter_ipb98y2"]}, "P_ICRF": {"produced_by": [], "used_by": ["Total auxiliary power"]}, "P_LHCD": {"produced_by": [], "used_by": ["Total auxiliary power"]}, "P_NBI": {"produced_by": [], "used_by": ["Total auxiliary power"]}, "P_aux": {"produced_by": ["Total auxiliary power"], "used_by": ["Physics gain factor"]}, "P_aux_el": {"produced_by": [], "used_by": ["Engineering gain factor"]}, "P_charged": {"produced_by": ["Charged fusion power"], "used_by": []}, "P_fus": {"produced_by": ["Total fusion power"], "used_by": ["Physics gain factor"]}, "P_fus_DD": {"produced_by": ["DD fusion power"], "used_by": ["Total fusion power"]}, "P_fus_DDn": {"produced_by": ["DD (He3+n) fusion power"], "used_by": ["DD fusion power"]}, "P_fus_DDn_He3": {"produced_by": ["DDn helium-3 power"], "used_by": ["Charged fusion power", "DD (He3+n) fusion power"]}, "P_fus_DDn_n": {"produced_by": ["DDn neutron power"], "used_by": ["DD (He3+n) fusion power", "Neutron fusion power"]}, "P_fus_DDp": {"produced_by": ["DD (T+p) fusion power"], "used_by": ["DD fusion power"]}, "P_fus_DDp_T": {"produced_by": ["DDp triton power"], "used_by": ["Charged fusion power", "DD (T+p) fusion power"]}, "P_fus_DDp_p": {"produced_by": ["DDp proton power"], "used_by": ["Charged fusion power", "DD (T+p) fusion power"]}, "P_fus_DHe3": {"produced_by": ["D-He3 fusion power"], "used_by": ["Total fusion power"]}, "P_fus_DHe3_alpha": {"produced_by": ["D-He3 alpha power"], "used_by": ["Charged fusion power", "D-He3 fusion power"]}, "P_fus_DHe3_p": {"produced_by": ["D-He3 proton power"], "used_by": ["Charged fusion power", "D-He3 fusion power"]}, "P_fus_DT": {"produced_by": ["DT fusion power"], "used_by": ["Total fusion power"]}, "P_fus_DT_alpha": {"produced_by": ["DT alpha power"], "used_by": ["Charged fusion power", "DT fusion power"]}, "P_fus_DT_n": {"produced_by": ["DT neutron power"], "used_by": ["DT fusion power", "Neutron fusion power"]}, "P_fus_TT": {"produced_by": ["TT fusion power"], "used_by": ["Total fusion power"]}, "P_fus_el": {"produced_by": [], "used_by": ["Engineering gain factor"]}, "P_loss": {"produced_by": [], "used_by": ["Energy confinement time", "Sudo density limit", "tau_E_hubbard_nominal", "tau_E_iter_ipb98y2"]}, "P_neutron": {"produced_by": ["Neutron fusion power"], "used_by": []}, "P_sep": {"produced_by": [], "used_by": ["P_sep metric", "P_sep ratio"]}, "P_sep_B_over_q95AR": {"produced_by": ["P_sep metric"], "used_by": []}, "P_sep_over_R": {"produced_by": ["P_sep ratio"], "used_by": []}, "Q_eng": {"produced_by": ["Engineering gain factor"], "used_by": []}, "Q_sci": {"produced_by": ["Physics gain factor"], "used_by": []}, "R": {"produced_by": ["Major radius"], "used_by": ["Aspect ratio", "IPB elongation from volume", "P_sep metric", "P_sep ratio", "Sudo density limit", "Tokamak surface", "Tokamak volume", "tau_E_iter_ipb98y2"]}, "R_max": {"produced_by": [], "used_by": ["Elongation", "Major radius"]}, "R_min": {"produced_by": [], "used_by": ["Elongation", "Major radius"]}, "Rr_DDn": {"produced_by": ["DD (He3+n) reaction rate"], "used_by": ["DDn helium-3 power", "DDn neutron power"]}, "Rr_DDp": {"produced_by": ["DD (T+p) reaction rate"], "used_by": ["DDp proton power", "DDp triton power"]}, "Rr_DHe3": {"produced_by": ["D-He3 reaction rate"], "used_by": ["D-He3 alpha power", "D-He3 proton power"]}, "Rr_DT": {"produced_by": ["DT reaction rate"], "used_by": ["DT alpha power", "DT neutron power"]}, "Rr_He3He3": {"produced_by": ["He3-He3 reaction rate"], "used_by": []}, "Rr_THe3": {"produced_by": ["T-He3 reaction rate"], "used_by": []}, "Rr_TT": {"produced_by": ["T-T reaction rate"], "used_by": ["TT fusion power"]}, "S_p": {"produced_by": ["Tokamak surface"], "used_by": []}, "T0": {"produced_by": [], "used_by": ["Peak pressure"]}, "T_avg": {"produced_by": [], "used_by": ["D-He3 reaction rate", "DD (He3+n) reaction rate", "DD (T+p) reaction rate", "DT reaction rate", "He3-He3 reaction rate", "T-He3 reaction rate", "T-T reaction rate"]}, "T_e": {"produced_by": [], "used_by": ["Thermal pressure"]}, "T_i": {"produced_by": [], "used_by": ["Thermal pressure"]}, "T_i_peak": {"produced_by": [], "used_by": ["Fusion triple product", "Peak pressure"]}, "V_p": {"produced_by": ["Tokamak volume"], "used_by": ["D-He3 reaction rate", "DD (He3+n) reaction rate", "DD (T+p) reaction rate", "DT reaction rate", "He3-He3 reaction rate", "IPB elongation from volume", "T-He3 reaction rate", "T-T reaction rate", "Thermal stored energy"]}, "W_th": {"produced_by": ["Thermal stored energy"], "used_by": ["Energy confinement time"]}, "Z_max": {"produced_by": [], "used_by": ["Elongation"]}, "Z_min": {"produced_by": [], "used_by": ["Elongation"]}, "a": {"produced_by": [], "used_by": ["Aspect ratio", "Greenwald density limit", "IPB elongation from volume", "Normalized beta", "Sudo density limit", "Tokamak surface", "Tokamak volume", "Troyon beta limit"]}, "afuel": {"produced_by": ["Average fuel mass number"], "used_by": ["tau_E_iter_ipb98y2"]}, "beta": {"produced_by": ["Beta decomposition"], "used_by": []}, "beta_N": {"produced_by": ["Normalized beta"], "used_by": []}, "beta_T": {"produced_by": ["Toroidal beta"], "used_by": ["Beta decomposition", "Normalized beta"]}, "beta_limit": {"produced_by": ["Troyon beta limit"], "used_by": []}, "beta_p": {"produced_by": ["Poloidal beta"], "used_by": ["Beta decomposition"]}, "delta": {"produced_by": ["ST triangularity vs aspect ratio", "Triangularity 95%"], "used_by": ["Tokamak surface", "Tokamak volume"]}, "delta_95": {"produced_by": [], "used_by": ["Triangularity 95%"]}, "dnla20": {"produced_by": [], "used_by": ["tau_E_hubbard_nominal"]}, "f_D": {"produced_by": ["Deuterium fraction from density", "Ion fraction normalization (solve f_D)"], "used_by": ["Average fuel mass number", "D-He3 reaction rate", "DD (He3+n) reaction rate", "DD (T+p) reaction rate", "DT reaction rate", "Deuterium density from fraction", "Electron density from ion fractions", "Ion fraction normalization (solve f_He3)", "Ion fraction normalization (solve f_He4)", "Ion fraction normalization (solve f_T)"]}, "f_GW": {"produced_by": ["Greenwald density fraction"], "used_by": []}, "f_He3": {"produced_by": ["Helium-3 fraction from density", "Ion fraction normalization (solve f_He3)"], "used_by": ["Average fuel mass number", "D-He3 reaction rate", "Electron density from ion fractions", "He3-He3 reaction rate", "Helium-3 density from fraction", "Ion fraction normalization (solve f_D)", "Ion fraction normalization (solve f_He4)", "Ion fraction normalization (solve f_T)", "T-He3 reaction rate"]}, "f_He4": {"produced_by": ["Helium-4 fraction from density", "Ion fraction normalization (solve f_He4)"], "used_by": ["Average fuel mass number", "Electron density from ion fractions", "Helium-4 density from fraction", "Ion fraction normalization (solve f_D)", "Ion fraction normalization (solve f_He3)", "Ion fraction normalization (solve f_T)"]}, "f_T": {"produced_by": ["Ion fraction normalization (solve f_T)", "Tritium fraction from density"], "used_by": ["Average fuel mass number", "DT reaction rate", "Electron density from ion fractions", "Ion fraction normalization (solve f_D)", "Ion fraction normalization (solve f_He3)", "Ion fraction normalization (solve f_He4)", "T-He3 reaction rate", "T-T reaction rate", "Tritium density from fraction"]}, "kappa": {"produced_by": ["Elongation", "Elongation 95%", "ST elongation vs aspect ratio"], "used_by": ["Tokamak surface", "Tokamak volume"]}, "kappa_95": {"produced_by": [], "used_by": ["Elongation 95%"]}, "kappa_ipb": {"produced_by": ["IPB elongation from volume"], "used_by": ["tau_E_iter_ipb98y2"]}, "n0": {"produced_by": [], "used_by": ["Peak pressure"]}, "n_D": {"produced_by": ["Deuterium density from fraction"], "used_by": ["Deuterium fraction from density"]}, "n_GW": {"produced_by": ["Greenwald density limit"], "used_by": ["Greenwald density fraction"]}, "n_He3": {"produced_by": ["Helium-3 density from fraction"], "used_by": ["Helium-3 fraction from density"]}, "n_He4": {"produced_by": ["Helium-4 density from fraction"], "used_by": ["Helium-4 fraction from density"]}, "n_SUDO": {"produced_by": ["Sudo density limit"], "used_by": []}, "n_T": {"produced_by": ["Tritium density from fraction"], "used_by": ["Tritium fraction from density"]}, "n_avg": {"produced_by": [], "used_by": ["Electron density from volume-averaged density", "Greenwald density fraction"]}, "n_e": {"produced_by": ["Electron density from ion fractions", "Electron density from volume-averaged density"], "used_by": ["Thermal pressure"]}, "n_i": {"produced_by": [], "used_by": ["D-He3 reaction rate", "DD (He3+n) reaction rate", "DD (T+p) reaction rate", "DT reaction rate", "Deuterium density from fraction", "Deuterium fraction from density", "Electron density from ion fractions", "He3-He3 reaction rate", "Helium-3 density from fraction", "Helium-3 fraction from density", "Helium-4 density from fraction", "Helium-4 fraction from density", "T-He3 reaction rate", "T-T reaction rate", "Thermal pressure", "Tritium density from fraction", "Tritium fraction from density"]}, "n_i_peak": {"produced_by": [], "used_by": ["Fusion triple product", "Peak pressure"]}, "n_i_tau_E_T_i": {"produced_by": ["Fusion triple product"], "used_by": []}, "n_la": {"produced_by": [], "used_by": ["tau_E_iter_ipb98y2"]}, "p_peak": {"produced_by": ["Peak pressure"], "used_by": []}, "p_th": {"produced_by": ["Thermal pressure"], "used_by": ["Poloidal beta", "Thermal stored energy", "Toroidal beta"]}, "q95": {"produced_by": [], "used_by": ["P_sep metric"]}, "squareness": {"produced_by": [], "used_by": ["Tokamak surface", "Tokamak volume"]}, "tau_E": {"produced_by": ["Energy confinement time", "tau_E_hubbard_nominal", "tau_E_iter_ipb98y2"], "used_by": ["Fusion triple product"]}};
window.relConnections = {"Aspect ratio": {"inputs": ["R", "a"], "outputs": ["A"]}, "Average fuel mass number": {"inputs": ["f_D", "f_He3", "f_He4", "f_T"], "outputs": ["afuel"]}, "Beta decomposition": {"inputs": ["beta_T", "beta_p"], "outputs": ["beta"]}, "Charged fusion power": {"inputs": ["P_fus_DDn_He3", "P_fus_DDp_T", "P_fus_DDp_p", "P_fus_DHe3_alpha", "P_fus_DHe3_p", "P_fus_DT_alpha"], "outputs": ["P_charged"]}, "D-He3 alpha power": {"inputs": ["Rr_DHe3"], "outputs": ["P_fus_DHe3_alpha"]}, "D-He3 fusion power": {"inputs": ["P_fus_DHe3_alpha", "P_fus_DHe3_p"], "outputs": ["P_fus_DHe3"]}, "D-He3 proton power": {"inputs": ["Rr_DHe3"], "outputs": ["P_fus_DHe3_p"]}, "D-He3 reaction rate": {"inputs": ["T_avg", "V_p", "f_D", "f_He3", "n_i"], "outputs": ["Rr_DHe3"]}, "DD (He3+n) fusion power": {"inputs": ["P_fus_DDn_He3", "P_fus_DDn_n"], "outputs": ["P_fus_DDn"]}, "DD (He3+n) reaction rate": {"inputs": ["T_avg", "V_p", "f_D", "n_i"], "outputs": ["Rr_DDn"]}, "DD (T+p) fusion power": {"inputs": ["P_fus_DDp_T", "P_fus_DDp_p"], "outputs": ["P_fus_DDp"]}, "DD (T+p) reaction rate": {"inputs": ["T_avg", "V_p", "f_D", "n_i"], "outputs": ["Rr_DDp"]}, "DD fusion power": {"inputs": ["P_fus_DDn", "P_fus_DDp"], "outputs": ["P_fus_DD"]}, "DDn helium-3 power": {"inputs": ["Rr_DDn"], "outputs": ["P_fus_DDn_He3"]}, "DDn neutron power": {"inputs": ["Rr_DDn"], "outputs": ["P_fus_DDn_n"]}, "DDp proton power": {"inputs": ["Rr_DDp"], "outputs": ["P_fus_DDp_p"]}, "DDp triton power": {"inputs": ["Rr_DDp"], "outputs": ["P_fus_DDp_T"]}, "DT alpha power": {"inputs": ["Rr_DT"], "outputs": ["P_fus_DT_alpha"]}, "DT fusion power": {"inputs": ["P_fus_DT_alpha", "P_fus_DT_n"], "outputs": ["P_fus_DT"]}, "DT neutron power": {"inputs": ["Rr_DT"], "outputs": ["P_fus_DT_n"]}, "DT reaction rate": {"inputs": ["T_avg", "V_p", "f_D", "f_T", "n_i"], "outputs": ["Rr_DT"]}, "Deuterium density from fraction": {"inputs": ["f_D", "n_i"], "outputs": ["n_D"]}, "Deuterium fraction from density": {"inputs": ["n_D", "n_i"], "outputs": ["f_D"]}, "Electron density from ion fractions": {"inputs": ["f_D", "f_He3", "f_He4", "f_T", "n_i"], "outputs": ["n_e"]}, "Electron density from volume-averaged density": {"inputs": ["n_avg"], "outputs": ["n_e"]}, "Elongation": {"inputs": ["R_max", "R_min", "Z_max", "Z_min"], "outputs": ["kappa"]}, "Elongation 95%": {"inputs": ["kappa_95"], "outputs": ["kappa"]}, "Energy confinement time": {"inputs": ["P_loss", "W_th"], "outputs": ["tau_E"]}, "Engineering gain factor": {"inputs": ["P_aux_el", "P_fus_el"], "outputs": ["Q_eng"]}, "Fusion triple product": {"inputs": ["T_i_peak", "n_i_peak", "tau_E"], "outputs": ["n_i_tau_E_T_i"]}, "Greenwald density fraction": {"inputs": ["n_GW", "n_avg"], "outputs": ["f_GW"]}, "Greenwald density limit": {"inputs": ["I_p", "a"], "outputs": ["n_GW"]}, "He3-He3 reaction rate": {"inputs": ["T_avg", "V_p", "f_He3", "n_i"], "outputs": ["Rr_He3He3"]}, "Helium-3 density from fraction": {"inputs": ["f_He3", "n_i"], "outputs": ["n_He3"]}, "Helium-3 fraction from density": {"inputs": ["n_He3", "n_i"], "outputs": ["f_He3"]}, "Helium-4 density from fraction": {"inputs": ["f_He4", "n_i"], "outputs": ["n_He4"]}, "Helium-4 fraction from density": {"inputs": ["n_He4", "n_i"], "outputs": ["f_He4"]}, "IPB elongation from volume": {"inputs": ["R", "V_p", "a"], "outputs": ["kappa_ipb"]}, "Ion fraction normalization (solve f_D)": {"inputs": ["f_He3", "f_He4", "f_T"], "outputs": ["f_D"]}, "Ion fraction normalization (solve f_He3)": {"inputs": ["f_D", "f_He4", "f_T"], "outputs": ["f_He3"]}, "Ion fraction normalization (solve f_He4)": {"inputs": ["f_D", "f_He3", "f_T"], "outputs": ["f_He4"]}, "Ion fraction normalization (solve f_T)": {"inputs": ["f_D", "f_He3", "f_He4"], "outputs": ["f_T"]}, "Major radius": {"inputs": ["R_max", "R_min"], "outputs": ["R"]}, "Neutron fusion power": {"inputs": ["P_fus_DDn_n", "P_fus_DT_n"], "outputs": ["P_neutron"]}, "Normalized beta": {"inputs": ["B0", "I_p", "a", "beta_T"], "outputs": ["beta_N"]}, "P_sep metric": {"inputs": ["A", "B0", "P_sep", "R", "q95"], "outputs": ["P_sep_B_over_q95AR"]}, "P_sep ratio": {"inputs": ["P_sep", "R"], "outputs": ["P_sep_over_R"]}, "Peak pressure": {"inputs": ["T0", "T_i_peak", "n0", "n_i_peak"], "outputs": ["p_peak"]}, "Physics gain factor": {"inputs": ["P_aux", "P_fus"], "outputs": ["Q_sci"]}, "Poloidal beta": {"inputs": ["B_p", "p_th"], "outputs": ["beta_p"]}, "ST elongation vs aspect ratio": {"inputs": ["A"], "outputs": ["kappa"]}, "ST triangularity vs aspect ratio": {"inputs": ["A"], "outputs": ["delta"]}, "Sudo density limit": {"inputs": ["B0", "P_loss", "R", "a"], "outputs": ["n_SUDO"]}, "T-He3 reaction rate": {"inputs": ["T_avg", "V_p", "f_He3", "f_T", "n_i"], "outputs": ["Rr_THe3"]}, "T-T reaction rate": {"inputs": ["T_avg", "V_p", "f_T", "n_i"], "outputs": ["Rr_TT"]}, "TT fusion power": {"inputs": ["Rr_TT"], "outputs": ["P_fus_TT"]}, "Thermal pressure": {"inputs": ["T_e", "T_i", "n_e", "n_i"], "outputs": ["p_th"]}, "Thermal stored energy": {"inputs": ["V_p", "p_th"], "outputs": ["W_th"]}, "Tokamak surface": {"inputs": ["R", "a", "delta", "kappa", "squareness"], "outputs": ["S_p"]}, "Tokamak volume": {"inputs": ["R", "a", "delta", "kappa", "squareness"], "outputs": ["V_p"]}, "Toroidal beta": {"inputs": ["B0", "p_th"], "outputs": ["beta_T"]}, "Total auxiliary power": {"inputs": ["P_ICRF", "P_LHCD", "P_NBI"], "outputs": ["P_aux"]}, "Total fusion power": {"inputs": ["P_fus_DD", "P_fus_DHe3", "P_fus_DT", "P_fus_TT"], "outputs": ["P_fus"]}, "Triangularity 95%": {"inputs": ["delta_95"], "outputs": ["delta"]}, "Tritium density from fraction": {"inputs": ["f_T", "n_i"], "outputs": ["n_T"]}, "Tritium fraction from density": {"inputs": ["n_T", "n_i"], "outputs": ["f_T"]}, "Troyon beta limit": {"inputs": ["B0", "I_p", "a"], "outputs": ["beta_limit"]}, "tau_E_hubbard_nominal": {"inputs": ["B0", "I_p", "P_loss", "dnla20"], "outputs": ["tau_E"]}, "tau_E_iter_ipb98y2": {"inputs": ["A", "B0", "I_p", "P_loss", "R", "afuel", "kappa_ipb", "n_la"], "outputs": ["tau_E"]}};
window.relationTags = {"tau_E_hubbard_nominal": ["I-mode", "confinement", "tokamak"], "tau_E_iter_ipb98y2": ["H-mode", "confinement", "tokamak"], "Thermal stored energy": ["plasma"], "Energy confinement time": ["plasma"], "Major radius": ["geometry"], "Aspect ratio": ["geometry"], "Elongation": ["geometry"], "Elongation 95%": ["geometry", "tokamak"], "Triangularity 95%": ["geometry", "tokamak"], "IPB elongation from volume": ["geometry"], "Tokamak volume": ["geometry", "tokamak"], "Tokamak surface": ["geometry", "tokamak"], "ST elongation vs aspect ratio": ["geometry", "spherical_tokamak"], "ST triangularity vs aspect ratio": ["geometry", "spherical_tokamak"], "Troyon beta limit": ["plasma", "tokamak"], "Greenwald density limit": ["plasma", "tokamak"], "Greenwald density fraction": ["plasma", "tokamak"], "Sudo density limit": ["plasma", "stellarator"], "Electron density from volume-averaged density": ["plasma"], "Electron density from ion fractions": ["plasma"], "Deuterium density from fraction": ["plasma"], "Tritium density from fraction": ["plasma"], "Helium-3 density from fraction": ["plasma"], "Helium-4 density from fraction": ["plasma"], "Deuterium fraction from density": ["plasma"], "Tritium fraction from density": ["plasma"], "Helium-3 fraction from density": ["plasma"], "Helium-4 fraction from density": ["plasma"], "Ion fraction normalization (solve f_D)": ["plasma"], "Ion fraction normalization (solve f_T)": ["plasma"], "Ion fraction normalization (solve f_He3)": ["plasma"], "Ion fraction normalization (solve f_He4)": ["plasma"], "Average fuel mass number": ["plasma"], "Fusion triple product": ["fusion_power"], "Physics gain factor": ["fusion_power"], "Engineering gain factor": ["fusion_power"], "Total fusion power": ["fusion_power"], "Charged fusion power": ["fusion_power"], "Neutron fusion power": ["fusion_power"], "DT fusion power": ["fusion_power"], "DT alpha power": ["fusion_power"], "DT neutron power": ["fusion_power"], "DD fusion power": ["fusion_power"], "DD (T+p) fusion power": ["fusion_power"], "DD (He3+n) fusion power": ["fusion_power"], "DDp triton power": ["fusion_power"], "DDp proton power": ["fusion_power"], "DDn helium-3 power": ["fusion_power"], "DDn neutron power": ["fusion_power"], "D-He3 fusion power": ["fusion_power"], "D-He3 alpha power": ["fusion_power"], "D-He3 proton power": ["fusion_power"], "TT fusion power": ["fusion_power"], "DT reaction rate": ["fusion_power"], "DD (He3+n) reaction rate": ["fusion_power"], "DD (T+p) reaction rate": ["fusion_power"], "D-He3 reaction rate": ["fusion_power"], "T-T reaction rate": ["fusion_power"], "He3-He3 reaction rate": ["fusion_power"], "T-He3 reaction rate": ["fusion_power"], "Toroidal beta": ["plasma"], "Poloidal beta": ["plasma"], "Beta decomposition": ["plasma"], "Normalized beta": ["plasma"], "Thermal pressure": ["plasma"], "Peak pressure": ["plasma"], "Total auxiliary power": ["auxiliary", "power_exhaust"], "P_sep ratio": ["power_exhaust"], "P_sep metric": ["power_exhaust"]};

function setInfo(text) {
  var panel = document.getElementById('info-panel');
  if (!panel) return;
  panel.textContent = text;
}

function getGraphObjects() {
  var networkObj = null;
  var nodesObj = null;
  var edgesObj = null;

  if (window.__relationGraph__ && window.__relationGraph__.network) {
    networkObj = window.__relationGraph__.network;
    nodesObj = window.__relationGraph__.nodes;
    edgesObj = window.__relationGraph__.edges;
  }

  if (!networkObj && window.network) networkObj = window.network;
  if (!networkObj && (typeof network !== 'undefined')) networkObj = network;

  if (!nodesObj && window.nodes) nodesObj = window.nodes;
  if (!nodesObj && (typeof nodes !== 'undefined')) nodesObj = nodes;

  if (!edgesObj && window.edges) edgesObj = window.edges;
  if (!edgesObj && (typeof edges !== 'undefined')) edgesObj = edges;

  // Fallback: derive datasets from the network instance
  try {
    if (networkObj && networkObj.body && networkObj.body.data) {
      nodesObj = nodesObj || networkObj.body.data.nodes;
      edgesObj = edgesObj || networkObj.body.data.edges;
    }
  } catch (e) {}

  return { network: networkObj, nodes: nodesObj, edges: edgesObj };
}

function formatRelationInfo(name) {
  var lines = ['Relation: ' + name];
  var conn = (window.relConnections || {})[name];
  if (conn) {
    if (conn.inputs && conn.inputs.length) {
      lines.push('Inputs: ' + conn.inputs.join(', '));
    }
    if (conn.outputs && conn.outputs.length) {
      lines.push('Outputs: ' + conn.outputs.join(', '));
    }
  }
  var tags = (window.relationTags || {})[name];
  if (tags && tags.length) {
    lines.push('Tags: ' + tags.join(', '));
  }

  var infoItems = (window.relationInfo || {})[name];
  if (infoItems && infoItems.length) {
    lines.push('');
    for (var i = 0; i < infoItems.length; i++) {
      var it = infoItems[i];
      lines.push('---');
      lines.push((it.module || '') + ' :: ' + (it.function || '')); 
      if (it.source) {
        lines.push(it.source);
      }
    }
  } else {
    lines.push('');
    lines.push('(No source details found.)');
  }
  return lines.join('\n');
}

function formatVariableInfo(name) {
  var lines = ['Variable: ' + name];
  var meta = (window.variableInfo || {})[name];
  if (meta) {
    lines.push('');
    lines.push(meta);
  } else {
    // Maybe this was an alias
    var hits = (window.variableAliases || {})[name];
    if (hits && hits.length) {
      lines.push('');
      lines.push('Alias for: ' + hits.join(', '));
    }
  }

  var conn = (window.varConnections || {})[name];
  if (conn) {
    lines.push('');
    lines.push('produced_by: ' + (conn.produced_by.length ? conn.produced_by.join(', ') : '(none)'));
    lines.push('used_by: ' + (conn.used_by.length ? conn.used_by.join(', ') : '(none)'));
  }

  return lines.join('\n');
}

function initInteraction() {
  var g = getGraphObjects();
  var network = g.network;
  var nodes = g.nodes;
  var edges = g.edges;

  if (!network || !nodes || !edges) {
    // Keep retrying; this happens on some pyvis templates.
    setTimeout(initInteraction, 250);
    return;
  }

  // Store for debugging / reuse.
  window.__relationGraph__ = { network: network, nodes: nodes, edges: edges };

  function unselectAll() {
    if (network.unselectAll) {
      network.unselectAll();
      return;
    }
    if (network.setSelection) {
      network.setSelection({ nodes: [], edges: [] });
    }
  }

  function selectNodes(ids) {
    if (network.selectNodes) {
      network.selectNodes(ids);
      return;
    }
    if (network.setSelection) {
      network.setSelection({ nodes: ids, edges: [] });
    }
  }

  function selectEdges(ids) {
    if (network.selectEdges) {
      network.selectEdges(ids);
      return;
    }
    if (network.setSelection) {
      network.setSelection({ nodes: [], edges: ids });
    }
  }

  function handleClick(params) {
    try {
      if (params.nodes && params.nodes.length) {
        var nodeId = params.nodes[0];
        setInfo(formatVariableInfo(nodeId));
        return;
      }
      if (params.edges && params.edges.length) {
        var edgeId = params.edges[0];
        var edge = edges.get(edgeId);
        var relName = (edge && (edge.relation || edge.label)) || 'relation';
        setInfo(formatRelationInfo(relName));
      }
    } catch (e) {
      console.error('relation_graph: click handler failed', e);
    }
  }

  network.on('click', handleClick);
  network.on('selectNode', handleClick);
  network.on('selectEdge', handleClick);

  var suggestionBox = document.getElementById('search-suggestions');
  var toolbox = document.getElementById('relation-toolbox');

  function buildSearchIndex() {
    var items = [];
    var seen = {};
    function add(label, value, type) {
      var key = type + '|' + label;
      if (seen[key]) return;
      seen[key] = true;
      items.push({ label: String(label), value: String(value), type: type });
    }

    var nodeIds = nodes.getIds();
    for (var i = 0; i < nodeIds.length; i++) {
      var id = nodeIds[i];
      add(id, id, 'variable');
    }

    var relNames = Object.keys(window.relationInfo || {});
    for (var j = 0; j < relNames.length; j++) {
      add(relNames[j], relNames[j], 'relation');
    }

    var aliasNames = Object.keys(window.variableAliases || {});
    for (var k = 0; k < aliasNames.length; k++) {
      add(aliasNames[k], aliasNames[k], 'alias');
    }

    var relTags = window.relationTags || {};
    var relTagKeys = Object.keys(relTags);
    for (var t = 0; t < relTagKeys.length; t++) {
      var rel = relTagKeys[t];
      var tags = relTags[rel] || [];
      for (var tt = 0; tt < tags.length; tt++) {
        add('#' + tags[tt], '#' + tags[tt], 'tag');
      }
    }

    return items;
  }

  function hideSuggestions() {
    if (!suggestionBox) return;
    suggestionBox.style.display = 'none';
    suggestionBox.innerHTML = '';
  }

  function showSuggestions(items) {
    if (!suggestionBox) return;
    suggestionBox.innerHTML = '';
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var row = document.createElement('div');
      row.className = 'suggestion';
      row.textContent = item.label + ' [' + item.type + ']';
      row.dataset.value = item.value;
      row.addEventListener('click', function(evt) {
        var value = evt.currentTarget.dataset.value;
        var input = document.getElementById('search-input');
        if (input) input.value = value;
        hideSuggestions();
        doSearch();
      });
      suggestionBox.appendChild(row);
    }
    suggestionBox.style.display = 'block';
  }

  function updateSuggestions() {
    var input = document.getElementById('search-input');
    if (!input) return;
    if (!window.searchIndex) {
      window.searchIndex = buildSearchIndex();
    }
    var term = input.value.trim();
    if (!term) {
      hideSuggestions();
      return;
    }
    var termNorm = term.toLowerCase();
    var maxItems = 10;
    var matches = [];
    var seen = {};

    for (var i = 0; i < window.searchIndex.length; i++) {
      var item = window.searchIndex[i];
      var label = item.label.toLowerCase();
      if (label.indexOf(termNorm) === 0 || label.indexOf(termNorm) !== -1) {
        if (!seen[item.label]) {
          seen[item.label] = true;
          matches.push(item);
          if (matches.length >= maxItems) break;
        }
      }
    }

    if (!matches.length) {
      hideSuggestions();
      return;
    }
    showSuggestions(matches);
  }

  function doSearch() {
    var input = document.getElementById('search-input');
    if (!input) return;
    var term = input.value.trim();
    hideSuggestions();

    if (!term) {
      unselectAll();
      setInfo('Click a node or edge to view details.');
      return;
    }

    function normalize(value, caseSensitive) {
      return caseSensitive ? String(value) : String(value).toLowerCase();
    }

    function collectTagMatches(matchFn) {
      var matches = {};
      var relTags = window.relationTags || {};
      var relNames = Object.keys(relTags);
      for (var i = 0; i < relNames.length; i++) {
        var relName = relNames[i];
        var tags = relTags[relName] || [];
        for (var j = 0; j < tags.length; j++) {
          var tag = tags[j];
          if (matchFn(tag)) {
            if (!matches[tag]) matches[tag] = [];
            if (matches[tag].indexOf(relName) === -1) matches[tag].push(relName);
          }
        }
      }
      return matches;
    }

    function attemptTagSearch(tagTerm, caseSensitive) {
      var termNorm = normalize(tagTerm, caseSensitive);
      function exact(value) { return normalize(value, caseSensitive) === termNorm; }
      function contains(value) { return normalize(value, caseSensitive).indexOf(termNorm) !== -1; }

      var matches = collectTagMatches(exact);
      if (!Object.keys(matches).length) matches = collectTagMatches(contains);

      var tags = Object.keys(matches);
      if (!tags.length) return false;

      // Build relation set: any relation that has at least one matched tag
      var relSet = {};
      for (var t = 0; t < tags.length; t++) {
        var rels = matches[tags[t]] || [];
        for (var r = 0; r < rels.length; r++) relSet[rels[r]] = true;
      }

      var relNames = Object.keys(relSet).sort();

      // Build info text: list relations (and I/O if available)
      var lines = [];
      lines.push('Tag search: #' + tags.map(function(x){return x;}).join(', #'));
      lines.push('Relations (' + relNames.length + '):');

      var relConn = window.relationConnections || {};
      var relTags = window.relationTags || {};

      for (var i = 0; i < relNames.length; i++) {
        var rel = relNames[i];
        var conn = relConn[rel] || {};
        var ins = (conn.inputs || []);
        var outs = (conn.outputs || []);
        var tgs = (relTags[rel] || []).map(function(x){ return '#' + x; });

        lines.push('');
        lines.push('- ' + rel + (tgs.length ? '  [' + tgs.join(' ') + ']' : ''));
        if (ins.length)  lines.push('  inputs:  ' + ins.join(', '));
        if (outs.length) lines.push('  outputs: ' + outs.join(', '));
      }

      setInfo(lines.join('\n'));

      // Select all edges whose relation is in relSet (keep your existing behavior)
      var edgeIds = [];
      var edgeList = edges.getIds();
      for (var e = 0; e < edgeList.length; e++) {
        var edge = edges.get(edgeList[e]);
        if (edge && relSet[edge.relation]) edgeIds.push(edgeList[e]);
      }
      if (edgeIds.length) {
        unselectAll();
        selectEdges(edgeIds);
      }

      return true;
    }


    var isTagSearch = term.charAt(0) === '#';
    if (isTagSearch) {
      var tagTerm = term.slice(1);
      if (!tagTerm) {
        setInfo('Type a tag after #');
        return;
      }
      if (attemptTagSearch(tagTerm, true)) return;
      if (attemptTagSearch(tagTerm, false)) return;
      setInfo('No tag match for: ' + term);
      return;
    }

    function findNode(matchFn) {
      var ids = nodes.getIds();
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var node = nodes.get(id);
        var label = (node && node.label) || id;
        if (matchFn(id) || matchFn(label)) return id;
      }
      return null;
    }

    function findEdge(matchFn) {
      var ids = edges.getIds();
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var edge = edges.get(id);
        var label = (edge && (edge.label || edge.relation)) || '';
        if (matchFn(label)) return id;
      }
      return null;
    }

    function findRelationName(matchFn) {
      var names = Object.keys(window.relationInfo || {});
      for (var i = 0; i < names.length; i++) {
        if (matchFn(names[i])) return names[i];
      }
      return null;
    }

    function findVariableName(matchFn) {
      var names = Object.keys(window.variableInfo || {});
      for (var i = 0; i < names.length; i++) {
        if (matchFn(names[i])) return names[i];
      }
      return null;
    }

    function findAlias(matchFn) {
      var aliases = Object.keys(window.variableAliases || {});
      for (var i = 0; i < aliases.length; i++) {
        if (matchFn(aliases[i])) return aliases[i];
      }
      return null;
    }

    function resolveAlias(alias) {
      var hits = (window.variableAliases || {})[alias] || [];
      return hits.length ? hits[0] : null;
    }

    function selectNode(nodeId) {
      selectNodes([nodeId]);
      try { if (network.focus) network.focus(nodeId, { scale: 1.3 }); } catch (e) {}
      setInfo(formatVariableInfo(nodeId));
    }

    function selectEdge(edgeId) {
      selectEdges([edgeId]);
      var edge = edges.get(edgeId);
      var relName = (edge && (edge.relation || edge.label)) || 'relation';
      setInfo(formatRelationInfo(relName));
    }

    function attemptSearch(caseSensitive) {
      var termNorm = normalize(term, caseSensitive);

      function exact(value) { return normalize(value, caseSensitive) === termNorm; }
      function startsWith(value) { return normalize(value, caseSensitive).indexOf(termNorm) === 0; }
      function contains(value) { return normalize(value, caseSensitive).indexOf(termNorm) !== -1; }

      var nodeId = findNode(exact);
      if (nodeId) { selectNode(nodeId); return true; }

      var relName = findRelationName(exact);
      if (relName) { setInfo(formatRelationInfo(relName)); return true; }

      var alias = findAlias(exact);
      if (alias) {
        var target = resolveAlias(alias);
        if (target) selectNode(target); else setInfo(formatVariableInfo(alias));
        return true;
      }

      nodeId = findNode(startsWith);
      if (nodeId) { selectNode(nodeId); return true; }

      nodeId = findNode(contains);
      if (nodeId) { selectNode(nodeId); return true; }

      var edgeId = findEdge(contains);
      if (edgeId) { selectEdge(edgeId); return true; }

      relName = findRelationName(contains);
      if (relName) { setInfo(formatRelationInfo(relName)); return true; }

      var varName = findVariableName(contains);
      if (varName) { setInfo(formatVariableInfo(varName)); return true; }

      alias = findAlias(contains);
      if (alias) {
        var target2 = resolveAlias(alias);
        if (target2) selectNode(target2); else setInfo(formatVariableInfo(alias));
        return true;
      }

      return false;
    }

    if (attemptSearch(true)) return;
    if (attemptSearch(false)) return;
    setInfo('No match for: ' + term);
  }

  var btn = document.getElementById('search-button');
  if (btn) btn.addEventListener('click', doSearch);

  var input = document.getElementById('search-input');
  if (input) {
    input.addEventListener('keydown', function(evt) {
      if (evt.key === 'Enter') doSearch();
    });
    input.addEventListener('input', updateSuggestions);
    input.addEventListener('focus', updateSuggestions);
  }

  if (toolbox) {
    document.addEventListener('click', function(evt) {
      if (!toolbox.contains(evt.target)) hideSuggestions();
    });
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initInteraction);
} else {
  initInteraction();
}
</script>

</body>
</html>